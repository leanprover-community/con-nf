% please preserve my preamble for ease of importing edited versions

% preamble \documentclass[12pt]{book}

% preamble \newtheorem{theorem}{Theorem}[section]
% preamble \newtheorem{lemma}[theorem]{Lemma}
% preamble \newtheorem{proposition}[theorem]{Proposition}
% preamble \newtheorem{corollary}[theorem]{Corollary}

% preamble \newenvironment{proof}[1][Proof]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{definition}[1][Definition]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{example}[1][Example]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{remark}[1][Remark]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

% preamble \newcommand{\qed}{\nobreak \ifvmode \relax \else
% preamble       \ifdim\lastskip<1.5em \hskip-\lastskip
% preamble       \hskip1.5em plus0em minus0.5em \fi \nobreak
% preamble       \vrule height0.75em width0.5em depth0.25em\fi}

% preamble \usepackage{amsmath}


% preamble \usepackage{amssymb}

% preamble \usepackage{hyperref}

% preamble \begin{document}

%% Locally defined macros
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\rge}{\mathrm{rge}}
\newcommand{\Pretangle}{\mathrm{Pretangle}}
\newcommand{\Sym}{\mathrm{Sym}}
\newcommand{\Str}{\mathrm{Str}}
\newcommand{\All}{\mathrm{All}}
\newcommand{\Cond}{\mathrm{Cond}}
\newcommand{\TTT}{\mathrm{TTT}}
\newcommand{\pathto}{\dashrightarrow}
\newcommand{\symdiff}{\mathrel{\triangle}}

\chapter{Phase 0: Preliminaries} \label{ch:preliminaries}

In this section, we give the background constructions for the model — as much as can be given before we enter into the main recursion.

\section{Cardinal parameters}

\begin{definition}
\label {def:params}
\leanok
\lean{con_nf.params}
Throughout, we fix three parameters:
\begin{itemize}
  \item $\lambda$ may be any limit ordinal;
  \item $\kappa$ may be any regular cardinal $>\lambda$;
  \item $\mu$ may be any strong limit cardinal $>\kappa$ of cofinality $\geq \kappa$.
\end{itemize}

[Note: The assumptions on $\kappa$ and $\mu$ are essential for the construction of the model to work.  The assumptions on $\lambda$ are not needed for this model — everything probably works for an arbitrary well-founded strict partial order $\lambda$, and gives a model of $\TTT_\lambda$. The assumption that $\lambda$ is a limit ordinals is require afterwards, to convert the model of $\TTT_\lambda$ into a model of $\mathrm{TST} + \text{typical ambiguity}$.]
\end{definition}

\begin{definition}
  \label {def:small}
  \uses{def:params}
  \leanok
  \lean{con_nf.small}
  We refer to sets of size smaller than $\kappa$ as \emph{small} [and all other sets as large].
  \end{definition}

\begin{definition}
\label {def:type-index}
\uses{def:params}
\leanok
\lean{con_nf.type_index}
We define a {\em type index} as an element of $\lambda^\bot := \lambda \cup \{-1\}$.
We define a {\em proper type index} as an element of $\lambda$.

In many ways, $-1$ should be viewed as a type index on the same footing as other elements of $\lambda$; but it frequently needs treating as a special case.

[In the formalisation, “$-1$” is referred to as $\bot$.  Should we consider following that in the text too?]
\end{definition}

\begin{definition}
\label{def:path}
\uses{def:type-index}
\leanok
\lean{con_nf.extended_index}
By a \emph{path}, we mean a path in the directed graph $(\lambda^\bot,<)$; that is, a nonempty finite strictly increasing sequence of type indices $\alpha_0 < \cdots < \alpha_k$.  A path is \emph{proper} if its source (least element) is proper.

We will write paths as $A : \beta \pathto \alpha$.  We will write path concatenation and extension as $\gamma;A$, $A;B$, and similar.

[There may be some terminological inconsistency: In places, paths are called \emph{extended type indices}, and are considered as sets rather than sequences; also, they are sometimes taken to be decreasing instead of increasing.]
\end{definition}

\section{Type $-1$: atoms, litters, and local cardinals}

We will define a function taking type indices $\alpha$ to sets $\tau_\alpha$ (type $\alpha$).

\newcommand{\Litter}{\mathcal{L}}
\newcommand{\NearLitter}{\mathcal{NL}}
\begin{definition}
\label{def:atoms-and-litters}
\uses{def:params}
\leanok
\lean{con_nf.atom,con_nf.litter}
Define $\Litter$ as $ (\lambda \cup \{-1\}) \times \lambda \times \mu$ and $\tau_{-1}$ as $\Litter \times \kappa$.

We refer to elements of $\tau_{-1}$ as \emph{atoms}.

By construction, atoms come partitioned into $\Litter$-many \emph{litters} of size $\kappa$,
\[ L_{\alpha,\beta,\xi} := \{((\alpha,\beta,\xi),x) \mid x \in \kappa \}.\]

The litters, in turn, come partitioned into $\lambda^2$-many classes of size $\mu$:
\[ X_{\alpha,\beta} := \{ (\alpha,\beta,\xi) \mid \xi \in \mu \}. \]

We generally identify litters $L_{\alpha,\beta,\xi}$ with their indices $(\alpha,\beta,\xi) \in \Litter$; for instance a quantification over “all litters” is formally a quantification over $\Litter$.
\end{definition}

The “atoms” of $\tau_{-1}$ are not quite atoms in a traditional sense — they do not appear as elements of the eventual structure — but they fulfil the same role of getting the set hierarchy off to a sufficiently non-trivial start.

\begin{definition}
\label {def:near-litter}
\uses{def:atoms-and-litters,def:small}
\leanok
\lean{con_nf.is_near_litter}
A \emph{near-litter} is a subset $N$ of $\tau_{-1}$ with small symmetric difference from some litter. This litter is necessarily unique, and we denote it by $N^\circ$.  We write $\NearLitter$ for the set of all near-litters.
\end{definition}

\begin{definition}
\label {def:local-cardinal}
\uses{def:near-litter}
\lean{con_nf.local_cardinal}
\leanok
For $i \in \Litter$, the $i$-th {\em local cardinal} $[L_i]$ is $\{N \subseteq \tau_{-1}:|N \symdiff L|<\kappa\}$.

For any near-litter $N$ (including litters), we write $[N]$ for the unique local cardinal that contains $N$. We introduce the notation $[N]^\circ$ for the litter belonging to the local cardinal $N$, with the tacit need to prove that there is only one.

[Note: almost all roles played by local cardinals in the original text should be fulfilled in the formalisation by litter-indices $i \in \Litter$.]
\end{definition}

\begin{lemma}
\label {lem:small-diff-equiv}
\uses{def:small}
\leanok
\lean{con_nf.is_near.trans}
Note that $\Litter$ corresponds to the equivalence classes of an equivalence relation $\sim$ on near-litters, where $X \sim Y$ iff the symmetric difference $X \symdiff Y$ is small.
\end{lemma}

\begin{proof}
\leanok
This is left as an easy exercise for the reader.
\end{proof}

\begin{lemma}
\label {lem:count-near-litters}
\uses{def:near-litter}
\leanok
\lean{con_nf.mk_near_litter}
Because the cofinality of $\mu$ is $\geq \kappa$, there are $\mu$ near-litters.
\end{lemma}

\begin{proof}
\leanok
First, there are at least $\mu$ near-litters. Second, the equivalence induced by the symmetric difference with the $i$-th litter sends near-litters to sets of size strictly less than $\kappa$, hence of size strictly less than the cofinality of $\mu$. But there are at most (exactly, in fact) $\mu$ such sets, because by definition of cofinality they are all bounded in $\mu$ and $\sum_{\alpha < \mu} 2 ^ \alpha = \mu $ because $\mu$ is a strong limit cardinal.
\end{proof}

One might be concerned with the fact that if $\mu$ has cofinality $\kappa$, it might have more than $\mu$ subsets of size $\kappa$:  but it still has only $\mu$ subsets of size $<\kappa$, and that is what matters for counting the near-litters:  a near-litter is determined as the symmetric difference of a litter ($\mu$ of these) and a small subset (cardinality $<\kappa$) of $\tau_{-1}$ (which is of size $\mu$) and there are only $\mu$ small subsets of $\tau_{-1}$.  If the cofinality of $\mu$ were less than $\kappa$, the cardinal arithmetic pathology mentioned as of concern could come into play.

\section{Preliminaries: pretangles, structural permutations}

Before embarking on the large recursive construction of the eventual model, we set up some structures in advance which we will make use of during the main recursion.

We first define a big structure, which can be viewed as a model of TTT without extensionality, whose elements we call \emph{pretangles}.  In the main recursion, we will carve out our actual model of TTT as a substructure of \emph{tangles} within the pretangles.

\begin{definition}
  \label{def:pretangle}
  \uses{def:atoms-and-litters}
  \leanok
  \lean{con_nf.pretangle}
  Define the sets $\Pretangle_\alpha$ of \emph{$\alpha$-pretangles} inductively. $\Pretangle_{-1}$ is defined as $\tau_{-1}$. For $\alpha$ a proper type index, $\Pretangle_\alpha$ is defined as $\prod_{\beta < \alpha} \mathcal P(\Pretangle_\beta)$.
\end{definition}

We also set up a sequence of groups that act on pretangles; subgroups of these will later act on the tangles.

\begin{definition}
  \label{def:structural-perm-atoms}
  \uses{def:near-litter}
  \leanok
  \lean{con_nf.near_litter_perm}

  A \emph{structural $(-1)$-permutation} [aka a near-litter-perm; we should fix on one name or the other] is a permutation $\pi$ of $\tau_{-1}$, along with a permutation $\bar{\pi}$ of litters, such that for each litter $L$, $\pi``(L)$ is near to $\bar{\pi}(L)$ (in the sense that they have small symmetric difference).  Denote the group of these by $\Str_{-1}$.

  [In fact $\bar{\pi}$ is uniquely determined by $\pi$ — we could define this just as a subgroup of $\Sym(\tau_{-1})$.  But it’s convenient in formalisation to have the $\bar{\pi}$ component explicit.]

  $\Str_{-1}$ has obvious actions on atoms and near-litters.
\end{definition}

\begin{definition}
  \label{def:structural-perm}
  \uses{def:structural-perm-atoms}
  \leanok
  \lean{con_nf.struct_perm}
  For a \emph{proper} type index $\alpha$, the structural $\alpha$-permutations are the group $\Str_\alpha = \prod_{\beta < \alpha} \Str_\beta$.
\end{definition}

\begin{definition}
  \label{def:structural-perm-derivative}
  \uses{def:structural-perm}
  \leanok
  \lean{con_nf.struct_perm.derivative}
  Any path $A : \beta \to \alpha$ gives a group homomorphism $(-)_A : \Str_\alpha \to \Str_\beta$.

  Moreover, this is functorial: they make $\Str$ into a functor $\mathrm{Path}(\Lambda)^\mathrm{op} \to \mathrm{Gp}$.

  [TODO: this should also depend on “paths”, but they aren’t yet explicitly in the blueprint.]
\end{definition}

\begin{definition}
  \label{def:allowable-perm-atoms}
  \uses{def:structural-perm-atoms}
  An \emph{allowable $(-1)$-permutation} is just a structural $(-1)$-permutation. We denote the group of these by $\All_{-1} = \Str_{-1}$.  (Later we will define $\Str_\beta$ as a proper subgroup of $\All_\beta$, for higher $\beta$.)
\end{definition}

\begin{definition}
  \label{def:support-condition}
  \uses{def:near-litter,def:atoms-and-litters} % TODO: add def:paths upstream, and add it here.
  \lean{con_nf.support_condition}
  \leanok
  Let $\alpha$ be a proper type index. An \emph{$\alpha$-condition} is a pair $(x,A)$, where $A$ is a path from $-1$ to $\alpha$ (aka an extended type index) and $x$ is either an atom or a near-litter.

  Type-theoretically, $\Cond := (\tau_{-1} + \NearLitter) \times \mathrm{Path}(-1,\alpha)$.
  [It would suffice to use just litters here instead of near-litters; they give an equivalent notion of support, as shown later (“replacing near-litters with litters”).  That makes a few things simpler; but using near-litters lets us talk about the action, Def.~\ref{def:support-condition-action}, which seems algebraically cleaner.]
\end{definition}

\begin{definition}
\label{def:support-condition-action}
\uses{def:structural-perm-derivative,def:support-condition}
\lean{con_nf.con_nf.support_condition.mul_action_2}
\leanok
Structural permutations act on support conditions.
\end{definition}

\begin{definition}
\label{def:support}
\uses{def:support-condition}
\lean{con_nf.potential_support}
\leanok
Let $\alpha$ be a proper type index. An $\alpha$-support is a small set of $\alpha$-support-conditions.  (A little more pedantically, one could call these something like “potential small supports”: they become actual supports once they support some element.)

[NOTES for formalisation: Well-orderings are assumed here in some version of Randall’s note, but they almost certainly aren’t wanted in the basic definition of supports, as used in phase 1. Strong supports, as used in phase 2, are probably better viewed as a separate notion: a more elaborate data structure that can be used to “present” a support in a particularly good way.]
\end{definition}

\begin{lemma}
\label {lem:count-supports}
\uses{def:support}
\lean{con_nf.mk_support_le}
\leanok
Because the cofinality of $\mu$ is $\geq \kappa$, there are $\mu$ potential supports, and therefore at most $\mu$ supports for each $x \in \tau$.
\end{lemma}
\begin{proof}
\uses{lem:count-near-litters}
\leanok
\end{proof}

\begin{definition}
\label{def:support-of}
  \uses{def:support,def:support-condition-action}
  \lean{con_nf.support}
  \leanok
  Suppose $\varphi : H \to \Str_\alpha$ is any group homomorphism, and $\tau$ is a set equipped with an $H$-action.

  Given $x \in \tau$ and $S$ any set of $\alpha$-support conditions, say \emph{$S$ supports $x$} if every $\pi \in H$ that fixes every element of $S$ also fixes $x$.

  A \emph{support for $x$} is a support (i.e.\ a \emph{small} set of conditions) that supports $x$. [Should we try to always say “small support” to avoid ambiguity?]

  We say $x$ is \emph{symmetric} if it has some small support.
\end{definition}

\chapter{Phase 1: The model construction} \label{ch:model-construction}

In this chapter, we give almost the entire construction of the structure which will (eventually) be a model of tangled type theory.

This should be read as an attempt at a recursion over the levels $\alpha \in \lambda$ of the structure.  We start by describing what data should exist at each level of the structure; then this section consists mostly of showing that given this data at each level $\beta < \alpha$, we can construct \emph{almost} all this data at level $\alpha$.

Unfortunately, one piece of the data is harder to propagate --- essentially just the fact that the set of tangles at level $\alpha$ is of size $< \mu$.  Proving this is not only lengthy, but also requires a more complex recursive assumption: not just data at each earlier level, but also information about how they interact between different levels.  This difference in the recursive assumptions is the motivation for the phase separation.

\section{Inductive assumptions}

For now, we group the data assumed at each level, according to which constructions it will be needed for.

\begin{definition}
  \label{def:phase-1-data}
  \uses{def:support-of,def:pretangle}
  \lean{con_nf.phase_1}

  Fix a proper type index $\alpha$.  Then \emph{phase 1 data at $\alpha$} consists of:
  \begin{enumerate}
    \item a group $\All$ (whose elements we call \emph{allowable permutations}), with a map $\varphi : \All \to \Str_\alpha$;
    \item a set $\tau$ (whose elements we call \emph{tangles}), equipped with an $\All$-action;
    \item a map $j$ (\emph{typed near-litters}) from near-litters to $\tau$, equivariant with respect to the $\All$-action on near-litters induced by $\All \to \Str_{\alpha} \to \Str_{-1}$;
    \item a map $k$ (\emph{typed singletons}) from $\tau_{-1}$ to $\tau$, again $\All$-equivariant w.r.t.\ the induced action on $\tau_{-1}$;
    \item for each $x \in \tau$, a small set $S_x$ of $\alpha$-support-conditions that supports $x$ under the $\All$-action (a \emph{designated support} for $x$);
    \item an injection $\iota : \tau \to \mu$, satisfying the following conditions:
    \begin{enumerate}
      \item each typed litter $j(L)$ precedes the typed singletons of all its elements $a \in L$ --- explicitly, $\iota(j(L)) < \iota(k(a))$;

      \item each typed near-litter $k(N)$ which is not a litter comes later than its (typed) litter $j(N^\circ)$, and after (the typed singletons of) all elements of $N \symdiff N^\circ$;

      \item for each $x$ in $\tau_\alpha$ that is not a typed litter or singleton, $x$ comes later than all of its designated support -- explicitly, for each $(a,A)$ or $(N,A)$ in $S_x$, we must have $\iota_\alpha(j(N)), \iota_\alpha(k(a))<\iota_\alpha(x)$.
    \end{enumerate}
    [Note: to see these conditions are not unreasonable, note that each $x \in \tau$ has $<\mu$ many things that it must come after, and that the chains of these constraints are of depth at most 4: litters $<$ atoms $<$ other near-litters $<$ everything else.  This is said more carefully in \cref{lem:position-functions-propagate} below.]
    \item [Optionally: An injection $\tau \to \Pretangle_\alpha$, equivariant with respect to the induced $\All$-action.  This may or may not be needed, depending on how the phase 2 data is organised.]
  \end{enumerate}
\end{definition}

When we assume this data at multiple levels, we will refer to the compomnents $\tau_\beta$, $\All_\beta$, and so on, and call their elements $\alpha$-tangles, etc.

Analogues of some of this data also exist at level $-1$, as the notation suggests: in particular, $\tau_{-1}$ and $\iota_{-1} : \tau_{-1} \to \mu$.  (But not the typed near-litters, or the further conditions on $\iota_{-1}$.) So, for instance, if we assume phase 1 data at all \emph{proper} levels $\beta < \alpha$, we may then refer to $\tau_\beta$ for all levels $\beta < \alpha$: for $\beta$ proper, this means the tangles of the assumed phase 1 data, while for $\beta = -1$ it means the fixed set of atoms $\tau_{-1}$.

\section{Phase 1a: Set codes and alternative extensions}

In the following few constructions, we will fix a proper type index $\alpha$ and assume we have phase 1 data given for all proper $\beta < \alpha$. (In fact some results --- in particular, the $f$-maps, $A$-maps and their properties --- only need to refer to the data at certain earlier levels.)

\begin{definition}
\label {def:code}
\uses{def:phase-1-data}
\lean{con_nf.code}
\leanok
An $\alpha$-code is a triple $(\alpha,\gamma,G)$ where $\gamma<\alpha$ and $G \subseteq \tau_\gamma$. [The original set-theoretic implementation includes the $\alpha$, to keep codes at different levels disjoint.  In the type-theoretic implementation, the first component $\alpha$ is unnecessary.]
\end{definition}

\begin{definition}
\label {def:f-map}
\uses{def:phase-1-data}
\lean{con_nf.f_map}
\leanok
We define, for all $\beta,\gamma < \alpha$, with $\gamma$ proper, a map $f_{\beta,\gamma}$ from $\tau_\beta$ to $X_{\beta,\gamma} \subseteq \mathrm{Litter}$, as follows.

For $x \in \tau_\beta$, $f_{\beta,\gamma}(x)$ is the litter $N^\circ$ of the minimal near-litter $N$ (under the ordering induced by $j_\beta \circ \iota_\beta : \NearLitter \to \tau_\beta \to \mu$) such that:
\begin{itemize}
  \item $N^\circ\in X_{(\beta,\gamma)}$, i.e. $N^\circ = L_{(\beta,\gamma,i)}$, for some $i$;
  \item for each nearby near-litter $M \sim N$, $\iota_\gamma(j_\gamma(M)) >\iota_\beta(x)$;
  \item $[N] \neq f_{\beta,\gamma}(y)$, for each $y <_\beta x$.
\end{itemize}

[This can be decomposed slightly at both ends.  Firstly, since we know that $f_{\beta_\gamma}(x) = (\beta,\gamma,\chi)$ for some $\chi$, we could take the output just to be the component $\chi \in \mu$, and turn it into a litter later.  Secondly, $f_{\beta_\gamma}(x)$ depends on $x$ essentially just via its position $i_\beta(x) \in \mu$, so we could start by defining a function $g_{\beta,\gamma} : \mu \to \mathrm{Litter}$, and then take $f_{\beta,\gamma}$ as the composite $g_{\beta,\gamma} \circ \iota_\beta$.  I don’t think these will really make a difference either way, though.]

[Notice that this only depends on a small fragment of the phase 1 data at $\beta$ and $\gamma$. In particular, it doesn’t depend on $\alpha$ nor on the phase 1 data at other levels. In the formalisation, it would be good to avoid it depending on more than it needs.]
\end{definition}

\begin{lemma}
  \label{lem:f-map-properties}
  \uses{def:f-map}
  \lean{con_nf.f_map_injective}
  \leanok
  The maps $f_{\beta,\gamma}$ satisfy:
  \begin{enumerate}
  \item each $f_{\beta,\gamma}$ is injective;
  \item their images are disjoint, for all different pairs $(\beta,\gamma)$;
  \item each $f_{\beta,\gamma}$ is “position-raising”: $\iota_\gamma(j_\gamma(N)) > \iota_\beta(x)$, for any near-litter $N$ near to the litter $L_{(\beta,\gamma,f_{\beta,\gamma}(x))}$.
  \end{enumerate}
\end{lemma}
\begin{proof}\leanok\end{proof}

\begin{definition}
\label {def:a-map}
\uses{def:f-map,def:code,def:local-cardinal}
\lean{con_nf.A_map}
\leanok
Let $\gamma$ be a type index (not necessarily proper) below $\alpha$.

For any code $(\alpha,\gamma,G)$, with $\delta$ a proper type index below $\alpha$ and distinct from $\gamma$, we define
$A_\delta(\alpha,\gamma,G)$ as
$$(\alpha,\delta,\{ j_\delta(N) \mid N \in \NearLitter,\, N \sim f_{\gamma,\delta}(b),\, b \in B \})$$
if the maps $f_{\gamma,\delta}$ are considered as valued in litters, or
$$(\alpha,\delta,\{ j_\delta(N) \mid N \in f_{\gamma,\delta}(b),\, b \in B \})$$
if they are taken as valued directly in local cardinals.

We say that a code $c$ \emph{leads to} a code $d$ if $d$ is the image of $c$ under some A-map. We denote this $c \rightsquigarrow d$.

(Here $j_\delta(N)$ is the “typed near-litters” map for level $\delta$, assumed in the phase 1 data.)

[For the formalisation, each individual $A_\delta$ is probably best represented as a function $\mathcal{P}(\tau_(\gamma)) \to \mathcal{P}(\tau_\delta)$, rather than on “codes of the form $(\alpha,\gamma,G)$…”.  Also it could — and perhaps should, for flexibility later — have parameters just “$\gamma$, $\delta$, and their phase 1 data”, rather than “$\alpha$, phase 1 data everywhere below $\alpha$, and $\gamma,\delta < \alpha$”.]
\end{definition}

\begin{lemma}
\label {lem:a-map-properties}
\uses{def:a-map}
\lean{con_nf.A_map_injective}
\leanok
\begin{enumerate}
\item Each $A_\delta$ is injective on nonempty codes.
\item The ranges of $A_\delta$ are disjoint for different $\delta$.
\end{enumerate}

NB: The disjointness of ranges depends on excluding the empty set --- either from the domains of the $A_\delta$ from the start, or else in the statement of this lemma.
\end{lemma}
\begin{proof}
\uses{lem:f-map-properties}
\leanok
\item Each $f_{\gamma,\delta}$ is injective, and $f_{\gamma,\delta}$ have disjoint images for different $\gamma$.
\item The ranges of $f_{\gamma,\delta}$ are disjoint for different $\delta$.
\end{proof}

\begin{lemma}
\label{lem:a-map-wf}
\uses{def:a-map}
\lean{con_nf.A_map_rel_well_founded}
\leanok
The relation $c \rightsquigarrow d$ on codes (“$c$ leads to $d$ under some $A$-map”) is well-founded.
\end{lemma}

\begin{proof}
\uses{lem:a-map-properties}
\leanok
  Consider the map $m$ from codes to $\mu$ sending $(\alpha,\gamma,X)$ to $\min \iota_\gamma``X$, where $\iota_\gamma : \tau_\gamma \to \mu$ is the position function assumed in the phase 1 data.

  The definition of the functions $A_{\delta,\gamma}$ and the fact that $\iota f_{\gamma,\delta}(x) > \iota x $ ensure that $j(\alpha,\gamma,X) < j(A_\delta(\alpha,\gamma,X))$, for all suitable $\gamma,\delta,X$.

  In other words, if $c \rightsquigarrow c'$, then $m(c) < m(c')$ in $\mu$.  It follows that $\rightsquigarrow$ is well-founded.
\end{proof}

\begin{definition}
\label {def:code-parity}
\uses{def:a-map}
\lean{con_nf.code.is_even}
\leanok
A code is \emph{even} if it only leads to odd codes. A code is \emph{odd} if it leads to some even code.

Note: This exactly says that even codes are the losing positions of the game whose states are codes
and possible moves are taking the preimage under some A-map.
\end{definition}

\begin{lemma}
\label {lem:code-parity-properties}
\uses{def:code-parity}
\lean{con_nf.code.is_even_or_is_odd}
\leanok
\begin{enumerate}
\item All codes are even or odd.
\item An odd nonempty code only leads to even codes.
\end{enumerate}
\end{lemma}
\begin{proof}
\uses{lem:a-map-wf}
\leanok
\begin{enumerate}
\item $\rightsquigarrow$ is well-founded.
\item An odd nonempty code leads to an even code and the A-maps are injective on nonempty codes and have disjoint ranges.
\end{enumerate}
\end{proof}

\begin{definition}
\label {def:code-equiv}
\uses{lem:code-parity-properties}
\lean{con_nf.code.equiv}
\leanok
We define an equivalence relation $\equiv_\alpha$ on $\alpha$-codes inductively:
\begin{enumerate}
\item For every code $c$, $c \equiv_\alpha c$.
\item If $(\alpha,\gamma,G)$ is even and $\gamma \neq \delta$, then $(\alpha,\gamma,G) \equiv_\alpha A_\delta (\alpha,\gamma,G)$ and $A_\delta (\alpha,\gamma,G) \equiv_\alpha (\alpha,\gamma,G)$.
\item If $(\alpha,\gamma,G)$ is even and $\gamma \neq \delta, \varepsilon$, then $A_\delta (\alpha,\gamma,G) \equiv_\alpha A_\varepsilon (\alpha,\gamma,G)$.
\end{enumerate}

This is reflexive and symmetric by definition, and transitive by using the properties of code parity.
\end{definition}

\begin{lemma}
\label{lem:code-equiv-properties}
\uses{def:code-equiv}
\leanok
\lean{con_nf.code.equiv.unique}
Under $\equiv_\alpha$, each code is equivalent to
\begin{enumerate}
\item exactly one even code
\item exactly one code of extension $\gamma$ for all $\gamma \ne -1$, $\gamma < \alpha$
\item at most one code of extension $-1$
\end{enumerate}
\end{lemma}
\begin{proof}
\leanok
\end{proof}

\begin{definition}
  \label{def:semi-tangle}
  \uses{lem:code-equiv-properties}
  \lean{con_nf.semitangle}
  \leanok
  An \emph{$\alpha$-semi-tangle} is an element $x$ of $\prod_{\beta < \alpha}\mathcal P(\tau_\beta) \times (\alpha + \mathcal P(\tau_{-1}))$, whose components we denote $x_\beta$, such that:
  \begin{itemize}
    \item if $x_{-1}$ is some $\beta < \alpha$, then $(\alpha,\beta,x_\beta)$ is a representative code, and for each other $\gamma$, $A_{\beta,\gamma}(\alpha,\beta,x_\beta) = (\alpha,\gamma,x_\gamma)$;
    \item if $x_{-1}$ is a set of atoms, then $(\alpha,-1,x_{-1})$ is a representative code, and for each other $\gamma$, $A_{-1,\gamma}(\alpha,-1,x_{-1}) = (\alpha,\gamma,x_\gamma)$;
  \end{itemize}

  [Note that these are intermediate between “pretangles” and “tangles”.  Also note that — as with pretangles — we probably don’t need the “preferred extension” component.]

  [Actually it’s probably simpler to go back to representing these as representative codes for now, and just define here the components $x_\beta$, for later embedding them into pretangles.  It’s only in phase 2 that the embedding into pretangles will really become helpful!]
\end{definition}

\begin{definition}
\label{def:ttt-membership}
\uses{def:semi-tangle}
\lean{con_nf.semitangle.mem}
\leanok
  Membership relations of $\alpha$-semi-tangles, for the intended model of tangled type theory, can now be defined as follows: for each proper type index $\beta < \alpha$, and $x \in \tau_\beta$, and each $\alpha$-semi-tangle $y \in \tau_\alpha$, say $x \in_{TTT} y$ just if $x \in y_\beta$.
\end{definition}

This would be enough to enforce extensionality, but something much more radical needs to be done to make all this work, as we are assuming the existence of the maps $\iota_\beta$, which witness that all the types are of cardinality no greater than $\mu$.  There must therefore be a very strong restriction on which sets can appear as components of tangles.

This all cries out for a Theorem which should be here and which I left implicit in the original text.

\begin{theorem}
\label {thm:extensionality}
\uses{def:ttt-membership}
\lean{con_nf.semitangle.ext}
\leanok
For all proper type indices $\beta < \alpha$, $\beta$-tangles $x$, and $\alpha$-semitangles $y$, the following (nearly-obviously equivalent) statements hold:
\begin{itemize}
  \item if for all $z \in \tau_\beta$, $(z \in_{\tt TTT} x \leftrightarrow z \in_{\tt TTT} y)$, then $x=y$;
  \item if $x_\beta = y_\beta$, then $x=y$.
\end{itemize}
\end{theorem}
\begin{proof}\leanok\end{proof}

\section{Phase 1b: Actual tangles: the model definition}

  For the subsequent constructions of this section, we assume we are given phase 1 data for all $\beta < \alpha$.

\begin{definition}
\label {def:semiallowable-perm}
\lean{con_nf.semiallowable_perm}
\leanok
\uses{def:phase-1-data}
  A \emph{semi-allowable permutation} at level $\alpha$ is a family of allowable pemutations at all lower levels (including $-1$), $(\pi_\beta)_{\beta < \alpha} \in \prod_{\beta < \alpha} \All_\beta$.
\end{definition}

\begin{definition}
\label{def:code-action}
\uses{def:code,def:semiallowable-perm}
\lean{con_nf.semiallowable_perm.mul_action_code}
\leanok
Semi-allowable permutations act on $\alpha$-codes.
\end{definition}

\begin{definition}
  \label{def:allowable-perm}
  \uses{def:code-action,def:code-equiv}
  \lean{con_nf.allowable_perm}
  \leanok
  An \emph{allowable permutation} is a semi-allowable permutation which preserves $\equiv_\alpha$: for all $\alpha$-codes $X,Y$, $X \equiv_\alpha Y \leftrightarrow \pi(X) \equiv_\alpha \pi(Y)$.
\end{definition}

\begin{lemma}
\label {lem:coherence-unpacked}
\uses{def:allowable-perm}
\lean{con_nf.allowable_perm.coherence}
A semi-allowable permutation $\pi$ is allowable just if
$$f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``f_{\gamma,\delta}(g)^\circ].$$
holds for all $f_{\gamma,\delta}$ with $\gamma,\delta<\alpha$, and all $g \in \tau_\gamma$.
\end{lemma}

\begin{proof}
\leanok
This is discussion supporting the preceding lemma. The proof is given more carefully in Randall’s more recent version of the note.

The coherence condition can be unpacked.
$$(\beta,\gamma,\{g\}) \equiv_\beta (\beta,\delta,\{(\delta,-1,N):N \in f_{\gamma,\delta}(g)\})$$(where $\delta\neq \gamma$).  Thus we expect
$$\pi(\beta,\gamma,\{g\}) \equiv_\beta \pi(\beta,\delta,\{(\delta,-1,N):N \in f_{\gamma,\delta}(g)\})$$
that is,
$$(\beta,\gamma,\{\pi_\gamma(g)\}) \equiv_\beta (\beta,\delta,\{(\delta,-1,(\pi_\delta)_{-1}``N):N \in f_{\gamma,\delta}(g)\})$$
so $f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``L]$, where $f_{\gamma,\delta}(g)=[L]$.

Recalling the notations $N^\circ$ for the litter with small symmetric difference from the near-litter $N$, we can write this $$f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``f_{\gamma,\delta}(g)^\circ].$$

It is straightforward to show that this condition is equivalent to the coherence condition.  Notice that $\pi_\gamma$ imposes some restrictions on $\pi_\delta$, but only on the way it acts on certain typed near-litters (and of course there are reciprocal relations between $\pi_\delta$ and $\pi_\gamma$).
\end{proof}

\begin{lemma}
\label{lem:parity-action}
\lean{con_nf.code.is_even.smul}
\leanok
The action of allowable permutations on codes preserves parity.
\end{lemma}
\begin{proof}
  \uses{lem:coherence-unpacked,lem:code-equiv-properties}
\leanok
This should be straightforward.  A target should be the equation $\pi(A_\gamma(X)) = A_\gamma(\pi(X))$ for any allowable permutation $\pi$ and code $X$ for which $\pi_\gamma$ is defined.
\end{proof}

\begin{definition}
\label{def:semi-tangle-action}
\uses{def:semi-tangle,lem:parity-action}
\lean{con_nf.allowable_perm.mul_action_semitangle}
  Allowable permutations act on semi-tangles.
\end{definition}

\begin{definition}
\label{def:tangle}
\uses{def:semi-tangle-action,def:support-of}
\lean{con_nf.new_tangle}
\leanok
We take the set of $\alpha$-tangles, $\tau_\alpha$, to be the set of \emph{symmetric} $\alpha$-semi-tangles under the action of allowable permutations; that is, tangles that are supported by some small $\alpha$-support $S$,.
\end{definition}

\begin{lemma}
\label{lem:supportedness-equiv}
\uses{def:support-of,def:allowable-perm}
\lean{con_nf.code.equiv.symmetric_iff}
\leanok
If $X \subseteq \tau_\beta$, $Y \subseteq \tau_\gamma$, and $(\alpha,\beta,X) \equiv_\alpha (\alpha,\gamma,Y)$, then (under the action of allowable permutations on codes) a set $S$ of conditions supports $\beta$ if and only if it supports $\gamma$.  In particular,  $(\alpha,\beta,X)$ has some small support if and only if $(\alpha,\gamma,Y)$ does.
\end{lemma}

\begin{proof}
\leanok
  Immediate from the definition of allowable permutations.
\end{proof}

We state a couple of easy lemmas which are things we assumed in the inductive data, which must be shown to carry forward to $\tau_\alpha$.  There are more obligations of this sort which are harder to discharge, which will be provided in phase 2.

\begin{lemma}
\label{def:typed-near-litter}
\uses{def:tangle}
\lean{con_nf.typed_near_litter}
\leanok
Any code $(\alpha,-1,N)$, where $N$ is a near-litter, gives an element of $\tau_\alpha$.
\end{lemma}

\begin{proof}
\uses{lem:supportedness-equiv}
This code is obviously even [though this isn’t really necessary, thanks to Lemma~\ref{lem:supportedness-equiv}] and it is supported by a singleton condition, a suitable decorated version of $N$.
\end{proof}

\begin{lemma}
\label{def:typed-singleton}
\uses{def:tangle}
\lean{symmetric_singleton}
\leanok
For any symmetric $b \in \tau_\beta$, $(\alpha,\beta,\{b\}) \in \tau_\alpha$. In particular, this works for each atom $a \in \tau_{-a}$.
\end{lemma}

\begin{proof}
Take a $\beta$-support for $b$, and extend all the paths in it at the top by the step $\beta < \alpha$.  At level $-1$, any atom is clearly supported by its own singleton.

[This should be easy if we defined paths by induction from the top; if we have paths in reverse, it may need lemmas on how derivatives interact with extension at the top.  Or they might follow from functoriality of derivatives?]
\end{proof}

\begin{lemma}
\label {lem:small-subsets-closure}
\uses{def:tangle}
\lean{con_nf.symmetric_set}
\leanok
It should also be evident that $(\alpha,\beta,B)$ will always be symmetric if $|B|<\kappa$ [take the union of the $\beta$-supports of elements of $B$ and add $\alpha$ to all the second components of elements of this union]:  all small subsets of a type are realized in each higher type.
\end{lemma}

\begin{lemma}
  \label{lem:tangle-action}
  \uses{def:tangle}
  \lean{con_nf.allowable_perm.mul_action_new_tangle}
  \leanok
  The action of $\alpha$-allowable permutations on semi-tangles restricts to an action on tangles.  Explicitly, if an $\alpha$ semi-tangle $x$ is symmetric, then so is $\pi x$ for any $\alpha$-allowable permutation $\pi$.
\end{lemma}
\begin{proof}
  The algebra of group actions should show reasonably easily that if $\pi$ is an $\alpha$-allowable permutation and $X \in \tau_\alpha$ has $\alpha$-support $S$, then $\pi(X)$ has $\alpha$-support $\pi``S$.
\end{proof}

The obligation to prove that $\tau_\alpha$ is of size $\mu$ remains outstanding.  And of course we want to prove that the entire structure is a model of tangled type theory with $\tau_\gamma$ as type $\gamma$ for each $\gamma<\lambda$ and $\in_{\tt TTT}$ as its membership relation.

There is lots to be proven, but that is the entire description.

\section{Phase 1c: the embedding into pretangles}

[Note: this may not eventually be needed, depending on how the “coherence” in phase 2 is assumed.]

For the subsequent constructions of this section, we assume we are given phase 1 data for all $\beta < \alpha$.

\begin{definition}
  \label{def:embedding-into-pretangles}
  \uses{def:semi-tangle,def:phase-1-data}
  \lean{con_nf.new_tangle.to_pretangle}
  \leanok
  There is an evident injection $\tau_\alpha \to \Pretangle_\alpha$ (where $\tau_\alpha$ is constructed from the given phase 1 data).  Moreover, this commutes with the $\All_\alpha$-action.
\end{definition}

\section{Review}

Overall, we have now shown:

\begin{definition}
  \label{def:phase-1-propagates}
  \uses{def:phase-1,def:embedding-into-pretangles,def:typed-near-litter,def:typed-singleton,lem:tangle-action}
  For a proper type index $\alpha \in \lambda$, given phase 1 data at all levels $\beta < \alpha$, then the constructions above provide \emph{most} components of phase 1 data at level $\alpha$ — everything except for the embedding $\iota_\alpha : \tau_\alpha \to \mu$ and its properties.

  [Note that to treat this as a \emph{definition}, in particular of the “designated supports” component, we are implicitly invoking the axiom of choice --- a priori we only know that there \emph{exists} some support for each new tangle.]
\end{definition}

\newpage

\chapter{Phase 2: Constraining the number of tangles}

In this phase, we give the three hard theorems about the constructions of phase 1: strengthening supports, freedom of action, and constraining the number of tangles.

These meet the major technical difficulty of the recursion: We need (it seems) to assume not just that we have sets of tangles etc at all earlier levels, but also that they fit together correctly, in the sense of being inductively defined at all levels by the constructions so far.  This is the reason why we need the major phase separation in the components of the recursion.

\section{Inductive assumptions: Coherent data at all lower levels}

\begin{definition}
  \label{def:concrete-phase-1-data}
  \uses{def:phase-1-data}
  For a type index $\alpha$, \emph{concrete phase 1 data} at level $\alpha$ consists of a subset $\tau \subseteq \Pretangle_\alpha$ and a subgroup $\All \subseteq G_\alpha$, together with full phase 1 data on these.

  Notes for formalisation:
  \begin{itemize}
    \item The reason we use \emph{subsets} from here on is because we will soon impose equalities between these components, and subset equalities are much less nasty to deal with than type equalities.
    \item To define this, we almost certainly want to factor out the types $\tau$ and $\All$ as parameters of the phase 1 data from the start.
    \item We could avoid that “factoring out as a parameter” by assuming this concreteness already in the phase 1 data, i.e. positing $\tau$ as a subset of pretangles and $\All$ as a subgroup of $\Str_\alpha$ from the start.  At least for $\tau$, that seems a bit unnatural — it adds an entirely irrelevant extra assumption throughout phase 1.  For $\All$ it perhaps wouldn’t be so unnatural, since $\All$ does need to be assumed with at least a homomorphism to $\Str_\alpha$ anyway.
  \end{itemize}

  The \emph{standard} concrete phase 1 data at level $-1$ are the defined $\tau_{-1} = \Pretangle_{-1}$ and $\All_{-1} = \Str_{-1}$.
\end{definition}

\begin{definition}
  \label{def:concrete-phase-1-data-propagates}
  \uses{def:concrete-phase-1-data,def:phase-1-propagates}
  For a proper type index $\alpha \in \lambda$, given concrete phase 1 data at all levels $\beta < \alpha$, we get \emph{most} components of concrete phase 1 data at level $\alpha$.

  In particular, the new set of $\alpha$-tangles $\tau_\alpha \subseteq \Pretangle_\alpha$ is the the image of the $\alpha$-tangles defined in phase 1, under their embedding into pretangles; and similarly for the allowable permutations.  (We could call these “concrete $\alpha$-tangles” and “abstract $\alpha$-tangles”, if we need to for disambiguation.)
\end{definition}

\begin{definition}
  \label{def:coherent-phase-1-data}
  \uses{def:concrete-phase-1-data-propagates}
  For $\alpha \in \lambda + 1$, \emph{Phase 1 data below $\alpha$} consists of concrete phase 1 data at every level $\beta < \alpha$.  Say this is \emph{coherent} if it is standard at level $-1$, and at each proper type index $\beta < \gamma$, all components at level $\beta$ that \emph{could} have been induced from the data at lower levels $\gamma < \beta$ are, in fact, equal to what would have been induced that way.

  \begin{itemize}
  \item Note we want to provide this definiton also for $\alpha = \lambda$!  I think this should be available in mathlib as \verb|with_top|.
  \item We could unify “standard at level $-1$” with induced at proper type indices by generalising the definition of each component of the “induced concrete phase 1 data at $\alpha$” to include the case $\alpha = -1$,defining the induced data as the standard one in that case.  Is this more natural?  Will it make life easier?
  \end{itemize}

  For $\alpha < \beta$, “phase 2 data below $\alpha$” can be restricted to “phase 2 data below $\beta$”.

  Most constructions in phase 2 will assume coherent phase 1 data below $\alpha$, for some fixed $\alpha$.

  [Terminology: perhaps we should call this “phase 2 data at $\alpha$”?  That seems more consistent for the overall naming scheme, but “coherent phase 1 data below $\alpha$” seems clearer and more transparent in itself.  Maybe we should reconsider the naming scheme, so that it’s not in tension with clarity!]
\end{definition}

\section{Strong supports defined}

NOTE: much of this section has not been updated since early in the formalisation, so may not match the current implementation and abstractions very closely.

Throughout this section, fix some $\alpha \in \lambda + 1$, and assume coherent phase 1 data below $\alpha$. [Actually, perhaps this section doesn’t need the coherence and could be done in phase 1, i.e. working purely in a single level, assuming full phase 1 data is available at lower levels?  This should become clearer as it is formalised.]

Treating supports as sets suffices for the model description, but we will need to analyze supports and orbits with more care, so it is better for purposes
of the proof to equip supports with a well-orderings.

We may write $x \leq_S y$ for $(x,y) \in S$, and $x <_S y$ when we also want to indicate that $x,y$ are distinct.

If $\pi$ is an $\alpha$-allowable permutation and $S$ is an $\alpha$-support, we define $\pi[S]$ as $$\{((\pi_A(x),A,\gamma),(\pi_B(y),B,\delta)):((x,A,\gamma),(y,B,\delta))\in S\}.$$

If $S$ is an $\alpha$-support, we define $S^+$ as $\{(x,A,\alpha):(x,A,\alpha) \in S\}$.

We can then say that $S$ is a support of $X$ if $X$ is an $\alpha$-code, $S$ is an $\alpha$-support, and for any $\alpha$-allowable permutation $\pi$, if $\pi[S^+]=S^+$ then $\pi(x)=x$.  In some sense the items in the support with third components less than $\alpha$ are fluff, but they {\em are\/} important as we will see.

\begin{description}
\item[Remark on definitions of support and symmetry:]  It should be clear that the supports we have defined here do exactly the same work as the set supports in the model description (since the additional order structure and the third components of support domain elements actually do no work at this point).
\end{description}

% \begin{comment}
This probably represents a chunk of formal verification work, as what is obvious to people is not always obvious to theorem provers.
% \end{comment}

\begin{definition}
\label {def:raise-lower-index}
\uses{def:support-of}
[Note: all this stuff — raising and lowering indices, and the results about repeatedly applying them to structural permutations, etc — is MUCH more clearly handled in algebraic language, using the category of paths, the functoriality of $\Str_\alpha$ and $\All_\alpha$ in paths, and maps between group actions, etc.]

For any $\alpha$-support $S$ and an extended type index $C$ with minimum element greater than $\alpha$, we define $S^C$ as
$\{((x,A\cup C,\gamma),(y,B\cup C,\delta)):((x,A,\gamma),(y,B,\delta)) \in S\}$.

If $S$ is an $\alpha$-support and $\beta<\alpha$, $S_\beta$ is defined as the largest support $U$ such that $U^{\{\alpha\}} \subseteq S$ and $U$ is a $\beta$-support.
\end{definition}

\begin{definition}
\label{def:strong-support}
\uses{def:coherent-phase-1-data,def:raise-lower-index}
A strong support is a support $S$ with certain additional properties.

\begin{enumerate}
\item  If $((\beta,-1,x),A,\gamma) \in S$ then $x$ is a singleton or a litter.

\item  If $((\beta,-1,\{x\}),A,\gamma) \in S$, then $((\beta,-1,L),A,\gamma) <_S ((\beta,-1,\{x\}),A,\gamma)$, where $L$ is the litter containing $x$.

\item  If $((\beta,-1,L),A,\delta) \in S$ and $[L]=f_{\gamma,\beta}(y)$, where $\gamma<\delta$, then there is a $\gamma$-support $T$ of $y$ such that $T^{A \setminus \{\beta\}} \subseteq S$ and each element of the domain of $T^{A \setminus \{\beta\}}$ is $\leq_S ((\beta,-1,L),A)$.  Note that these conditions imply that there is an index-raised version of a strong $\gamma$-support of $y$ included in $T$.
\end{enumerate}
\end{definition}

\begin{lemma}
\label {lem:strengthen-support}
\uses{def:strong-support}
Any support can be extended to a strong support.
\end{lemma}

\begin{proof}
It should be straightforward to see that any $X$ with support $S$ has a support $S^\circ$ which satisfies the first condition.  Replace each element $((\beta,-1,x),A)$ of the domain of $S$ for which $x$ is a near-litter and not a litter with $((\beta,-1,x^\circ),A)$ and $((\beta,-1,\{y\}),A)$ for each $y$ in the symmetric difference of $x$ and $x^\circ$.

We describe the process of extending a support to a strong support, assuming that it already satisfies the first condition.  Before each typed singleton element of the domain, insert the appropriate typed litter (removing an extra copy of it if it occurred later in the order).  This will only need to be done once for each typed singleton element.

The condition $((\beta,-1,L),A,\delta) \in S$ and $[L]=f_{\gamma,\beta}(y)$ for $\gamma<\delta$ forces insertion of a $\gamma$-support for $y$.  Of course this might cause further insertions.  Notice that the third components of all inserted items will be $\leq \gamma <\delta$.  So it is not possible for an infinite regress of insertions to occur which would cause the extended support to fail to be a well-ordering.  (Of course, if an item is inserted which occurs later in the order, remove later occurrences).
\end{proof}

The third components in the elements of support domains seem actually to be necessary to ensure that strong supports can always be produced.  What the third component is doing is providing a comment on the index of the sub-support the element is required for.  There is another approach:  indexing the $f$ maps with $\alpha,\beta,\gamma$ instead of just $\beta,\gamma$ and requiring that ranges of $f$ maps with distinct indices be disjoint, which would require very straightforward modifications of the paper above, would ensure that we could tell the difference between insertions into an $\alpha$ support and insertions into a $\beta$-support for $\beta<\alpha$.  It seems that the added complexity is about the same with both approaches, and I have left it this way.  The approach used here also has the interesting effect that the extension over type $\gamma$ of a type $\alpha$ set is determined by its extension over type $\beta$ in a way which does not depend on $\alpha$;  it is interesting that this can be done.


% \begin{comment}
{\bf Note for the formal verification project:}  This should be ready to go.
% \end{comment}

\newpage
\section{Freedom of action of allowable permutations}

The practical application of strong supports is to the proof that allowable permutations act freely in a suitable sense, and in guiding applications of this theorem.

We claim that any locally small specification of values of derivatives of an allowable permutation at elements of type $-1$ can be realized.

We give an exact statement of what is meant, then we prove it.

\begin{definition}
\label {def:local-bijection}
\uses{def:path,def:atoms-and-litters,def:small}
\leanok
\lean{con_nf.local_bijection}
An $\alpha$-local bijection consists of: for each $\alpha$-extended type index (i.e.\ path $A : -1 \to \alpha$), a permutation $\pi^0_A$ of some subset $\dom(\pi^0_A) \subseteq \tau{-1}$, such that the intersection of $\dom(\pi^0_A)$ with any litter is small (including possibly empty).
\end{definition}

\begin{definition}
\label{def:perm-exception}
\uses{def:structural-perm-atoms}
\leanok
\lean{con_nf.near_litter_perm.exception}
We say that $x$ is an {\em exception} of a near-litter permutation $\pi$ iff ($L$ being the litter containing $x$) either $\pi(x) \not\in (\pi``L)^\circ$ or $\pi^{-1}(x) \not\in ({\pi^{-1}}``L)^\circ$.
\end{definition}

\begin{description}
\item[Stipulation:]  For each litter $L$ we specify a well-ordering $\leq_L$ of order type $\kappa$ with coordinated strict well-ordering $<_L$.  [In fact this is provided trivially by the current implementation of atoms.]
\end{description}

\begin{definition}
  \label{def:flexible}
  \uses{def:coherent-phase-1-data}
  Given coherent part 1 data below $\alpha$, a path $A : \beta \to \alpha$, and a litter $L$, say $L$ is \emph{$A$-flexible} (or that the pair $(L,A)$ is \emph{flexible}) if $L$ is not in the range of $f_{\beta,\gamma}$, for any $\gamma < \alpha$.

  (In particular, if $\beta = -1$, every such pair is flexible, since $f_{\gamma,\beta}$-maps is only defined for $\beta$ proper.)
\end{definition}

\begin{definition}
  \label{def:freedom-of-action-statement}
  \uses{def:perm-exception,def:local-bijection,def:flexible,def:allowable-perm-atoms}
  Given coherent part 1 data below $\alpha$, say that \emph{freedom of action holds (at $\alpha$)} if: Given an $\alpha$-local bijection $\pi^0$ and a specification for each path $A : \beta \to \alpha$ a bijection of the $\beta$-flexible litters, there is a unique allowable permutation $\pi \in \All_\alpha$ such that:
  \begin{enumerate}
   \item $\pi{A}$ extends $\pi^0_{A}$ for each $A$;
   \item for each path $A : \beta \to \alpha$ and $A$-flexible litter $L$, $\pi_A(j_\beta(L)) = j_\beta(N)$ for some $N$ near to $\chi_A(L)$;
   \item The only exceptions of $\pi$ are $\pi^0$, and everywhere else, $\pi$ is order-preserving between litters.  That is: for each path $A : -1 \to \alpha$ and litter $L$, and writing $N$ for the near-litter $\pi_A``L$, the restriction of $\pi_A$ to $L \setminus \dom(\pi^0_A)$ is the unique bijection from $L \setminus \dom(\pi^0_A)$ to $N^\circ \setminus \rge(\pi^0_A)$ which is strictly increasing with respect to the (given/canonical) orders on $L$ and $N^\circ$.
  \end{enumerate}

  Note: Earlier versions of the note/blueprint stated the 3rd condition in terms of exceptions; recent versions of the note spell it out in more detail and add the “increasing” condition, which is necessary for the uniqueness in the theorem conclusion.  If there are any doubts, the current version of Randall’s note should be consulted!
\end{definition}

\begin{lemma}
\label{lem:freedom-of-action-propagates}
\uses{def:freedom-of-action-statement}
Given coherent part 1 data below $\alpha$, if freedom of action holds at each level $\beta < \alpha$, then it holds at level $\alpha$.

Note: I (Peter) have an alternative approach to freedom of action (slightly different in both statement and proof) which might possibly be easier to formalise, avoiding the dependence on strong supports in the proof.  Iff Randall approves it then I will add it in the blueprint as an alternative.  But it doesn’t change the overall structure of the main argument/recursion, so this doesn’t need to be worried about until the point of formalising the FoA theorem itself.
\end{lemma}

\begin{proof}
  \uses{lem:strengthen-support}
  [This proof is is substantially clarified in more recent versions of Randall’s note.]

  We prove this by exhibiting a recursive procedure for computing $\pi$ and its derivatives along a strong support;  this succeeds because all objects have strong supports, and because computing all values of derivatives of $\pi$ on type $-1$ allows computation of all derivatives of $\pi$ at all types.

For each extended type index, we specify a permutation $\chi_A$ of local cardinals $[L]$ is not of the form $f_{\gamma,\beta}(y)$ for any $\gamma<{\tt min}(A)$ and $y \in \tau_\gamma$.

We consider an item $((\beta,-1,\{x\}),A,\gamma)$ and our aim is to compute $\pi_{A \cup \{-1\}}(x)$.  By hypothesis of the recursion, we have already
computed $\pi_A$ at $((\beta,-1,L),A)$, where $L$ is the litter which contains $x$.

There are two cases.  If $(A,x)$ is in the domain of $\pi^0$, we compute $\pi_{A \cup \{-1\}}(x) = \pi^0_A(x)$ and we are done.

Otherwise we use the hypothesis of the recursion:  we compute $\pi_{A \cup \{-1\}}(x)$ for any $x$ in $L$ with $(A,x)$ not in the domain of $\pi_0$ using the fact that we have already computed $\pi_A(\beta,-1,L) = (\beta,-1,N)$:  we define $\pi_{A \cup \{-1\}}$ to agree with the unique bijective map from the
elements of $L$ not in the domain of $\pi^0_A$ to the elements of $N^\circ$ not in the domain of $\pi^0_A$ which is strictly increasing in the sense that it sends larger objects in the sense of $<_L$ to larger objects in the sense of $<_{N^\circ}$.

Now we consider items of the form $((\beta,-1,L),A,\delta)$ in the strong support where $L$ is a litter.

If $[L]$ is not of the form $f_{\gamma,\beta}(y)$ for a $\gamma<{\tt min}(A)$ and $y \in \tau_\gamma$,
we compute $\pi_A((\beta,-1,L))$ as $$(\beta,-1,{\pi^0_A}``L \cup (\chi_A([L])^\circ \setminus {\pi^0_A}``(\tau_{-1} \setminus L))):$$ we map
$L$ to the near-litter in $\chi_A([L])$ with the exact modifications required by the local bijection.

If $[L]$ is of the form $f_{\gamma,\beta}(y)$ for a $\gamma<{\tt min}(A)$ and $y \in \tau_\gamma$ then we proceed just as above but we take the action on $[L]$ from a different source:
the coherence condition tells us that $[L]$ should be mapped to $f_{\gamma,\beta}(\pi_{A \setminus \{\beta\} \cup \{\gamma\}}(y))$, so we compute
$\pi_A((\beta,-1,L))$ as $$(\beta,-1,{\pi^0_A}``L \cup (f_{\gamma,\beta}(\pi_{A \setminus \{\beta\} \cup \{\gamma\}}(y))^\circ \setminus {\pi^0_A}``(\tau_{-1}\setminus L))),$$  which is essentially the same idea but a bit more complex.

The nasty recursive idea here is that we already know how to compute $\pi_{A \setminus \{\beta\} \cup \{\gamma\}}(y)$ from the embedded strong $\gamma$ support of $y$ because we assume as a hypothesis of the recursion that we already know how to carry out this computation for $\gamma$-supports, $\gamma<\alpha$.  The  local information we need about the $\gamma$ allowable permutation (the local bijection to be used and the relevant $\chi$ maps) is included in the information we are given initially about $\pi$ (though this data will have indices modified when used on the $\gamma$-support, of course).  Notice that we certainly do know how to do it for 0-supports, because the recursive clause will never be invoked if $\alpha=0$:  the rest of the procedure tells us what to do.

Once we know how to carry out this calculation along any $\alpha$-strong support, we can compute the derivatives of $\pi$ on elements of type $-1$  along all type paths, and so compute the value of $\pi$ and all of its derivatives on all types.  The method of calculation clearly gives an allowable permutation without exceptions other than those dictated by the local bijection.
\end{proof}

% \begin{comment}
{\bf Note for the formal verification project:}  This section is vitally important and should be ready to work on (once the model and the definition of strong support are handled).  Setting up the recursive definition of the computation may be nasty.
% \end{comment}

\begin{theorem}
  \label{thm:freedom-of-action}
  \uses{def:freedom-of-action-statement}
  Given coherent phase 1 data below $\alpha$, it satisfies freedom of action at every level.
\end{theorem}

\begin{proof}
  \uses{lem:freedom-of-action-propagates}
  By induction over $\beta < \alpha$, using \cref{lem:freedom-of-action-propagates}.
\end{proof}


\newpage
\section{Types are of size \texorpdfstring{$\mu$}{μ} (so the construction actually succeeds)}

[Note: this section is treated MUCH more clearly in Randall’s more recent versions of the note — we should certainly pull in from that newer version before attempting to formalise the section.]

Now we argue that (given that everything worked out correctly already at lower types) each type $\alpha$ is of size $\mu$, which ensures
that the construction actually succeeds at every type.

\begin{definition}
\label {def:coding-function}
\uses{def:coherent-phase-1-data}
For any support $S$ and tangle $x$, we can define a function $\chi_{x,S}$ which sends $T=\pi(S)$ to $\pi(x)$ for every $T$ in the orbit of $S$ under
the action of allowable permutations.  We call such functions {\em coding functions\/}.  Note that if $\pi[S]=\pi'[S]$ then $(\pi^{-1}\circ \pi')[S]= S$, so
$(\pi^{-1}\circ \pi')(x)= x$, so $\pi(x)=\pi'(x)$, ensuring that the map $\chi_{x,S}$ for which we gave an implicit definition is well defined.
\end{definition}

The strategy of our argument for the size of the types is to show that that there are $<\mu$ coding functions for each type whose domain includes a strong support, which implies that there are no more than $\mu$ (and so exactly $\mu$) elements of each type, since every element of a type is obtainable by applying a coding function (of which there are $<\mu$) to a support (of which there are $\mu$), and every element of a type has a strong support.

We describe all coding functions for type 0 (without concerning ourselves about whether supports are strong).  The orbit of a 0-support in the allowable permutations is determined by the positions in the support order occupied by near-litters, and for each position in the support order occupied by a singleton, the position, if any, of the near-litter in the support order which includes it.  There are no more than $2^\kappa$ ways to specify an orbit.  Now for each such equivalence class, there is a natural partition of type $-1$ into near-litters, singletons, and a large complement set.  Notice that near-litters in the partition will be obtained by removing any singletons in the domain of the support which are included in them.  The partition has $\nu<\kappa$ elements, and there will be $2^\nu\leq 2^\kappa$ coding functions for that orbit in the supports, determined by specifying for each compartment in the partition whether it is to be included or excluded from the set computed from a support in that orbit.  So there are no more than $2^\kappa<\mu$ coding functions over type 0.

We specify an object $X$ and a strong support $S$ for $X$, and develop a recipe for the coding function $\chi_{X,S}$ which can be used to see that there are $<\mu$ coding functions.

$X = (\alpha,\beta,B)$, where $B$ is a subset of $\tau_\beta$.  By inductive hypothesis, each element $b$ of $B$ can be expressed as $\chi_{b,T_b}(T_b)$, where $T_b$ is a strong support for $b$ end extending $S_\beta$ (which is defined as the largest $\beta$-support $U$ such that $U^{\{\alpha\}} \subseteq S$).

We claim that $\chi_{X,S}$ can be defined in terms of the orbit of $S$ in the allowable permutations and the set of coding functions $\chi_{b,T_b}$.  There are $<\mu$ sets of type $\beta$ coding functions by inductive hypothesis, and we will argue that there are $<\mu$ orbits in the $\alpha$-strong supports under allowable permutations, so this will imply that there are $\leq \mu$ elements of type $\alpha$ (it is obvious that there are $\geq \mu$ elements of each type).
Of course we get $\leq \mu$ codes for each $\beta<\alpha$, but we know that $\lambda<\kappa<\mu$.

The definition that we claim works is that $\chi_{X,S}(U) = (\alpha,\beta,B')$, where $B'$ is the set of all $\chi_{b,T_b}(U')$ for $b \in B$ and $U'$ end extending $U_\beta$.  Clearly this definition depends only on the orbit of $S$ and the set of coding functions derived from $B$.

The function we have defined is certainly a coding function, in the sense that $\chi_{X,S}(\pi(S)) = \pi(\chi_{X,S}(S))$.  What requires work is to show that
$\chi_{X,S}(S)=S$, from which it follows that it is in fact the intended function.

Clearly each $b \in B$ belongs to $\chi_{X,S}(S)$ as defined, because $b = \chi_{b,T_b}(T_b)$, and $T_b$ end extends $S_\beta$.

An arbitrary $c \in \chi_{X,S}(S)$ is of the form $\chi_{b,T_b}(U)$, where $U$ end extends $S_\beta$ and of course must be in the orbit of $T_b$ under allowable permutations.

Our strategy is to show that there is an allowable permutation $\pi$ which fixes $X$ (so that $\pi_\beta``B = B$) such that $\pi_\beta[T_b]=U$, so that
$\pi_\beta(b) = c$, so $c \in B$, whence $\chi_{X,S}(S)$ as defined is equal to $X$ as required.

We build a support $S+T_b^{\{\alpha\}}$ and a support $S+U^{\{\alpha\}}$ with parallel structure by appending $T_b$ (respectively $U$) to $S$ then removing all but the first occurrence of each repeated item.  The parallelism of structure is enforced by the identity of items taken from $S \setminus S_\beta$
in both supports and the fact that $U$ is the image of $T_b$ under some allowable permutation.

We construct an $\alpha$-allowable permutation whose action takes one of these supports to the other, which will complete the plan given above.
For this we use the freedom of action theorem.  We define a local bijection which sends $(A,x)$ to $y$ just in case a $(\beta,A,\{x\})$ in the first support corresponds to a $(\beta,A,\{y\})$ in the other, and further enforces agreement of derivatives  of the permutation to be constructed with derivatives of the known permutation $\pi'$ sending $T_b$ to $U$ at exceptions of derivatives of $\pi'$ which lie in litters in $T_b$.  This causes singleton items in the first support to be mapped to the corresponding singleton items in the other support.  We have to argue that litters in the domain of $S+T_b^{\{\alpha\}}$ (which is a strong support) are mapped to the correct near-litters in the domain of $S+U^{\{\alpha\}}$.  If there is a failure, there is a first one.  The local cardinal of the first failure is treated correctly (because a support of it is treated correctly), so the failure must consist in the map constructed having an exception which is moved by the permutation into or out of the litter in question (if a litter $L$ in $T_b$ is mapped to a near-litter $N$ in $U$, all elements of $N \symdiff N^\circ$ are treated correctly because they are values at exceptions of the known permutation), so a failure implies an exception of the constructed permutation lying in $L$ which is not an exception of the known map and whose singleton is not an item in $T_b$, and there are no such exceptions.

The constructed map fixes $X$ because of its identity action on $S$, and it sends $b$ to $c$ because its action sends $T_b$ to $U$, which is what we claimed,

The final move is to argue that there are $<\mu$ orbits in the $\alpha$-allowable permutations.  The idea is that the orbit in which a permutation lies
is completely determined by a certain amount of combinatorial information, similarly to what happened in type 0 but a bit more complex.  The orbit is specified if we know the second and third components of each item, taken from $\lambda$ items in each case, the first and second components of the first item, and whether the third component is a singleton or a near-litter.  If this is a singleton, we want to know the position in the support of a near-litter containing it (which will be present).  If this is a near-litter and its local cardinal is an image under an $f$ map, we can extract from information about the preceding part of the support order a subsupport which is an index-raised version of a strong support for the near-litter and so for its inverse image under the $f$ map:  as part of our specification, we take the coding function which generates that inverse image.

We give exact details.  If $S$ is a strong support (or an image of a strong support under an allowable permutation), we define
its specification $S^*$ as a well-ordering of the same length in which an item $((\beta,-1,x),A,\gamma)$ will be replaced by an item
$((\beta,-1,X),A,\gamma)$ in a way that we describe.  If $x=\{y\}$, we replace $x$ with $\{\delta\}$, where $\delta$ is the position of a typed near-litter containing $y$ in the obvious sense.  If $x$ is a near litter which does not belong to any $f_{\gamma,\beta}(y)$ with $\gamma<{\tt min}(A)$, then
$X= \emptyset$.  If $x \in f_{\gamma,\beta}(y)$ with $\gamma<{\tt min}(A)$, then we extract the maximal strong support $T$ of $y$ such that
$T^{\{\alpha\}} \subseteq S$, and set $X = \chi_{y,T}$, a coding function.

There is a straightforward argument by induction on the structure of strong supports that if we have two items with strong supports which have the same specification in the sense we have just described, there is an allowable permutation (by freedom of action) whose action sends the one support to the other, and so the one item to the other.

Suppose $S^* = T^*$:  we discuss the construction of an allowable permutation $\pi$ such that $\pi[S^*]=T^*$.  It should not be a surprise
that we construct the desired $\pi$ as an extension (as in the freedom of action theorem) of a local bijection defined by consulting the parallel structures of $S$ and $T$.  If $((\beta,-1,\{x\}),A,\delta)$ and $((\beta,-1,\{y\}),A,\delta)$ appear at corresponding positions in $S$ and $T$, we have $\pi^0$ send
$(A,x)$ to $y$.  If $((\beta,-1,M),A,\delta)$ and $((\beta,-1,N),A,\delta)$ appear at corresponding positions in $S$ and $T$ and $((\beta,-1,\emptyset),A,\delta)$ appears at the corresponding position in $S^*=T^*$, we can provide that the map $\chi_A$ used in the freedom of action construction
maps $[M]$ to $[N]$.  If $((\beta,-1,M),A,\delta)$ and $((\beta,-1,N),A,\delta)$ appear at corresponding positions in $S$ and $T$ and $((\beta,-1,\emptyset),\chi_{y,T},\delta)$ appears at the corresponding position in $S^*=T^*$,  then we know by the inductive hypothesis that everything works before this item in the support that the action of the permutation $\pi_A$ constructed so far will send $[M]$ to $[N]$.  In both near-litter cases, we need to do a little more work to ensure that $M$ is mapped exactly to $N$ without exceptions.  The idea is to extend $\pi^0_A$ so as to map each element of
$M$ which is not in $M^\circ$ to something in $N^\circ \cap N$, and each element of $M^\circ$ which is not in $M$ to something not in $N$, and do the analogous things for $(\pi^0_A)^{-1}$, and then fill in orbits, which only requires countably many atoms for each orbit [this is why we take $\kappa$ to be uncountable], with the rule that images and preimages chosen in the filling out process are chosen so as not to create exceptions (their images and preimages will agree with expected actions on near-litters in the supports, which is really action on their local cardinals, because all elements of the symmetric differences of near-litters with their corresponding litters are treated individually).  The extension of this local bijection will have exactly the desired effect.

There are clearly $<\mu$ specifications since these are small structures built with components taken from sets of size $<\mu$.  Notice the recursive dependency on the coding functions for items of lower types being taken from sets of size $<\mu$.

Pulling out the main items from the discussion above, for formalisation targets:

\begin{definition}
  \label{def:support-spec}
  \uses{def:coherent-phase-1-data}
  Fix coherent phase 1 data below $\alpha$.  A \emph{support-specification} is \ldots [this is quite long to define; we should get the text from more recent versions of Randall’s note]

  [Perhaps the coherence is not needed?]
\end{definition}

\begin{lemma}
  \label{lem:count-support-specs}
  \uses{def:support-spec}
  There are $<\mu$-many support specifications.
\end{lemma}

\begin{definition}
  \label{def:support-spec-realisation}
  \uses{def:support-spec,def:strong-support}
  Any support specification can be realised (non-uniquely) to give a strong support.
\end{definition}

\begin{lemma}
  \label{lem:support-spec-realisation-unique}
  \uses{def:support-spec-realisation,def:freedom-of-action-statement}
  If freedom of action holds at $\alpha$, then realisations of a support specification are unique modulo the group action.  That is, for any two realisations $S, S'$ of a support specification $S$, there is some allowable permutation $\pi$ such that $\pi S = S'$.

  [Note: we don’t need to explicitly assume freedom of action here: we could appeal to the \cref{thm:freedom-of-action} to know that it holds.  But the explicit assumption keeps things more modular, and avoids unnecessary dependency, which will be helpful in case it turns out the argument needs restructuring at any point.]
\end{lemma}

\begin{proof}
  Hopefully quite direct, given heavy use of freedom of action.  May need some lemmas about realisations.
\end{proof}

\begin{lemma}
  \label{lem:strong-support-has-spec}
  \uses{def:support-spec-realisation}
  Every strong support can be obtained as the realisation of some specification
\end{lemma}

\begin{corollary}
  \label{cor:count-strong-supports}
  \uses{def:strong-support}
  There are $<\mu$-many orbits of strong supports, under the group action of allowable permutations.
\end{corollary}

\begin{proof}
  \uses{lem:strong-support-has-spec,lem:count-support-specs}
  Immediate from \cref{lem:count-support-specs} and \cref{lem:strong-support-has-spec}.
\end{proof}

Now, everything that we did with supports, we repeat with coding functions.

\begin{definition}
  \label{def:coding-function-spec}
  \uses{def:support-spec,def:coding-function}
  A \emph{coding function specification} is \ldots [again, see recent versions of Randall’s note]

  [Perhaps the coherence is not needed?]
\end{definition}

\begin{lemma}
  \label{lem:count-coding-function-specs}
  \uses{def:coding-function-spec}
  There are $<\mu$-many coding function specifications.
\end{lemma}

\begin{definition}
  \label{def:coding-function-spec-realisation}
  \uses{def:coding-function-spec,def:support-spec-realisation}
  Any coding function specification can be realised as a coding function.
\end{definition}

\begin{lemma}
  \label{lem:coding-function-has-spec}
  \uses{def:coding-function-spec-realisation}
  Every coding function can be obtained as the realisation of some specification
\end{lemma}

\begin{proof}
  \uses{lem:strong-support-has-spec}
  See Randall’s more recent versions of the note.
\end{proof}

\begin{corollary}
  \label{cor:count-coding-functions}
  \uses{def:coding-function}
  There are $<\mu$-many coding functions.
\end{corollary}

\begin{proof}
  \uses{lem:coding-function-has-spec,lem:count-coding-function-specs}
  Immediate from \cref{lem:count-coding-function-specs} and \cref{lem:coding-function-has-spec}.
\end{proof}

\begin{corollary}
  \label{cor:count-tangles}
  \uses{def:freedom-of-action-statement}
  There are $\mu$-many $\alpha$-tangles.
\end{corollary}

\begin{proof}
  \uses{lem:count-supports,cor:count-coding-functions}
  Every tangle can be obtained as a coding function (of which there are $<\mu$) applied to a support (of which there are $\mu$).
\end{proof}

This completes the proof that each type is of size $\mu$, which finally closes the loop on the recursion --- or very nearly so: we still have to show that the orderings can be chosen to satisfy the extra technical conditions required.

\begin{lemma}
  \label{lem:position-functions-propagate}
  \uses{def:freedom-of-action-statement}
  Given coherent phase 1 data below $\alpha$ satisfying freedom of action at $\alpha$, we can choose supports $S(x)$ for all $\alpha$-tangles $x$ and a position function $\iota_\alpha : \tau_\alpha \to \mu$ satisfying the conditions demanded in \cref{def:phase-1-data}:
  \begin{enumerate}
    \item for each litter $L$, the typed litter of $L$ precedes the typed singletons of all its elements $a \in L$ --- explicitly, $\iota(j(L)) < \iota(k(a))$;
    \item for each near-litter $N$ which is not a litter, $j(N)$ comes after its (typed) litter $j(N^\circ)$, and after (the typed singletons of) all elements of $N \symdiff N^\circ$;

    \item for each $x$ in $\tau_\alpha$ that is not a typed litter or singleton, $x$ comes later than all of its designated support -- explicitly, for each $(a,A)$ or $(N,A)$ in the in $S(x)$, we must have $\iota_\alpha(j(N)), \iota_\alpha(k(a))<\iota_\alpha(x)$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  \uses{cor:count-tangles}
  The constraints can be seen as defining a relation $\prec$ on $\tau_\alpha$; we want to extend $\prec$ to a well-ordering of order-type $\leq \mu$, or equivalently, to give an injection $\iota:\tau_\alpha \to \mu$ sending $\prec$ to $<$.  We know:
  \begin{itemize}
  \item $\prec$ has depth 4: it is of the form “litters $\prec$ atoms $\prec$ other near-litters $\prec$ everything else”;
  \item each tangle has $<\kappa$-many predecessors under $\prec$;
  \item $|\tau_\mu| \leq \mu$.
  \end{itemize}
  These conditions should suffice to imply the existence of the desired ordering/functions.
\end{proof}

% \begin{comment}
{\bf Note for the formal verification project:}  I think everything is here, but filling in details to the satisfaction of a theorem prover will be work.
% \end{comment}

\section{Completing the recursion}

We can now wrap up the recursion.  It is a little subtle: to know that the recursion fits together right as we build it up, we need to pin it down some more, to make it uniquely determined.

[A probably cleaner approach would be to state and prove a general principle of \emph{$\lambda$-dependent-choice}, (it might be already in mathlib), and apply that to choices of coherent data, avoiding the need for “very coherent”.  The current approach is effectively unwinding what a general proof of $\lambda$-DC would give, applied to this case.]

\begin{definition}
  \label{def:very-coherent-data}
  \uses{lem:position-functions-propagate,thm:freedom-of-action}
  For $\alpha \in \lambda + 1$, a choice of coherent phase 1 data below $\alpha$ is \emph{very coherent} if its ordering functions and designated supports at each level are the ones provided by \cref{lem:position-functions-propagate} applied to the earlier levels, using \cref{thm:freedom-of-action} to supply the assumption of freedom of action.

  [This is sweeping a little under the rug. Both those theorems are stated as existentials, but they are used proof-relevantly here; so before this lemma, we must define “functions” that are just those theorems, wrung through the axiom of choice.  See also discusson above replacing this with an explicit principle of “dependent choice”.]
\end{definition}

\begin{lemma}
  \label{lem:very-coherent-data-unique}
  \uses{def:coherent-phase-1-data}
  For any $\alpha$, very coherent data below $\alpha$ is unique (if it exists).

  [Actually, we probably don’t need this: it effectively gets inlined in the main recursion.]
\end{lemma}
\begin{proof}
  By induction on $\beta < \alpha$: all components of the data at level $\beta$ are either propositions, or the coherence condition fixes them in terms of earlier data.
\end{proof}

\begin{theorem}
  \label{thm:main-recursion}
  \uses{def:very-coherent-data}
    For every $\alpha \in \lambda + 1$, there is a unique choice of very coherent data below $\alpha$.
\end{theorem}
\begin{proof}
  By induction on $\beta < \alpha$: take the unique choice below each $\beta < \alpha$; extend each one up to give very coherent data up-to-and-including each $\beta < \alpha$; and then by uniqueness, these fit together to give very coherent data below $\alpha$.
\end{proof}

\newcommand{\Tangle}{\mathrm{Tangle}}
\begin{definition}
  \label{def:tangle-completed}
  \uses{thm:main-recursion}
  The (genuine,definitive!) tangles are the substructure $\Tangle$ of $\Pretangle$ given by the unique choice of very coherent data up to $\lambda$, provided by \cref{thm:main-recursion}.
\end{definition}

\newpage

\chapter{Tangles model tangled type theory}

Now we can prove that the structure constructed in the previous chapters is a model of tangled type theory.

\section{The structure is a model of predicative TTT}

There is then a very direct proof that the structure presented is a model of predicative TTT (in which the definition of a set at a particular type may not mention any higher type).  Use $E$ for the membership relation of the structure.  It should be evident that $x E y \leftrightarrow \pi_\beta(x) E \pi(y)$,
where $x$ is of type $\beta$, $y$ is of type $\alpha$, and $\pi$ is an $\alpha$-allowable permutation.

Suppose that we are considering the existence of $\{x : \phi^s\}$, where $\phi$ is a formula of the language of TST with $\in$ translated as $E$, and $s$ is a strictly increasing sequence of types.  The truth value of each subformula of $\phi$ will be preserved if we replace each $x$ of type $s(i)$ with $\pi_{A_{s,i}}(x)$, where
$x=s(j)$ and $A_{s,i}$ is the set of all $s_k$ for $i \leq k \leq j+1$.  The formula $\phi$ will contain various parameters $a_i$ of types $s(n_i)$ and it is then evident that the set $\{x : \phi^s\}$ will be fixed by any $s(j+1)$-allowable permutation $\pi$ such that $\pi_{A{s,n_i}}$ fixes $a_i$ for each $i$.  But this means that
$(s(j+1),s(j),\{x : \phi^s\})$ is symmetric and belongs to type $s(j+1)$.

This procedure will certainly work if the set definition is predicative (all bound variables are of type no higher than that of $x$, parameters at the type
of the set being defined are allowed).

There are easier proofs of the consistency of predicative tangled type theory;  there is a reason of course that we have pursued this one.
% \begin{comment}
{\bf Note for the formal verification project:}  We note that in order to avoid metamathematics, we actually suggest proving finitely many instances of comprehension with typed parameters from which the full comprehension scheme can be deduced.  That there are such finite schemes (mod the infinite sequence of types) is well-known.
% \end{comment}

\newpage
\section{Impredicativity:  verifying the axiom of union}

What remains to complete the proof is that typed versions of the axiom of set union hold.  That this is sufficient is a fact about predicative type theory.
If we have predicative comprehension and union, we note that for any formula $\phi$, $\{\iota^k(x):\phi(x)\}$ will be predicative if $k$ is taken to be large enough, then application of union $k$ times to this set will give $\{x:\phi(x)\}$.  $\iota(x)$ here denotes $\{x\}$.  It is evidently sufficient to prove that unions of sets of singletons exist.

So what we need to show is that if $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ is symmetric, then $(\beta,\gamma,G)$ is symmetric.

Suppose that $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ is symmetric.  It then has a strong support $S$.  We claim that $S_\beta$ (same notion defined above) is a $\beta$-support for $(\beta,\gamma,G)$.

Suppose that $\pi[S_\beta]=S_\beta$.

Any $g \in G$ has a strong $\gamma$-support $T$ which extends $(S_\beta)_\gamma$.

Construct using freedom of action technology a permutation $\pi^*$ which acts as the identity on $S \setminus S_\beta$, such that $\pi^*_\beta$ agrees with $\pi$ on $S_\beta$ [so in fact $\pi^*$ will fix $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$) and $(\pi^*_\beta)_\gamma$ agrees with $\pi_\gamma$ on $T$, both on the orbits under $\pi$ of items in $T$ and on the orbits under $\pi$ of exceptions of $\pi$ which are in litters in $T$.  It will follow that $\pi^*$ fixes $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ and that $(\pi^*_\beta)_\gamma$ has the same value as $\pi_\gamma$ at $g$, which means that $\pi_\gamma(g) \in G$ (and the same things follow for the inverse of $\pi$) which verifies that that $S_\beta$ (same notion defined above) is a $\beta$-support for $(\beta,\gamma,G)$, so the axiom of union holds in the interpreted TTT.

The application of the freedom of action theorem works because no movement of typed atoms of type $\gamma$ stipulated by the behaviour of $\pi_\gamma$ can force
movement of elements of $S \setminus S_\beta$, because this would have to be mediated by the action of $\pi$ on $S_\beta$, which fixes all elements of $S_\beta$.
% \begin{comment}
{\bf Note for formal verification project:}  This is a high level description which will probably acquire more detailed text if we get to it.  The whole idea is here, I'm not saying there is a gap.  But I have a strong suspicion that unwinding the details will induce more text.
% \end{comment}

% preamble  \end{document}
