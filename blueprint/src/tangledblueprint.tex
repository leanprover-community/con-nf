% please preserve my preamble for ease of importing edited versions

% preamble \documentclass[12pt]{book}

% preamble \newtheorem{theorem}{Theorem}[section]
% preamble \newtheorem{lemma}[theorem]{Lemma}
% preamble \newtheorem{proposition}[theorem]{Proposition}
% preamble \newtheorem{corollary}[theorem]{Corollary}

% preamble \newenvironment{proof}[1][Proof]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{definition}[1][Definition]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{example}[1][Example]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% preamble \newenvironment{remark}[1][Remark]{\begin{trivlist}
% preamble \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

% preamble \newcommand{\qed}{\nobreak \ifvmode \relax \else
% preamble       \ifdim\lastskip<1.5em \hskip-\lastskip
% preamble       \hskip1.5em plus0em minus0.5em \fi \nobreak
% preamble       \vrule height0.75em width0.5em depth0.25em\fi}

% preamble \usepackage{amsmath}


% preamble \usepackage{amssymb}

% preamble \usepackage{hyperref}

% preamble \begin{document}

%% Locally defined macros
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\rge}{\mathrm{rge}}
\newcommand{\Pretangle}{\mathrm{Pretangle}}
\newcommand{\Sym}{\mathrm{Sym}}
\newcommand{\Str}{\mathrm{Str}}
\newcommand{\All}{\mathrm{All}}
\newcommand{\Cond}{\mathrm{Cond}}
\newcommand{\BiCond}{\mathrm{BiCond}}
\newcommand{\TTT}{\mathrm{TTT}}
\newcommand{\pathto}{\dashrightarrow}
\newcommand{\symdiff}{\mathrel{\triangle}}
\newcommand{\Path}{\mathrm{Path}}
\newcommand{\op}{\mathrm{op}}
\newcommand{\pow}{\mathcal{P}}

\chapter{Phase 0: Preliminaries} \label{ch:preliminaries}

In this section, we give the background constructions for the model — as much as can be given before we enter into the main recursion.

\section{Cardinal parameters}

\begin{definition}
\label {def:params}
\leanok
\lean{con_nf.params}
Throughout, we fix three parameters:
\begin{itemize}
  \item $\lambda$ may be any limit ordinal;
  \item $\kappa$ may be any regular cardinal $>\lambda$;
  \item $\mu$ may be any strong limit cardinal $>\kappa$ of cofinality $\geq \kappa$.
\end{itemize}

[Note: The assumptions on $\kappa$ and $\mu$ are essential for the construction of the model to work.  The assumptions on $\lambda$ are not needed for this model — everything probably works for an arbitrary well-founded strict partial order $\lambda$, and gives a model of $\TTT_\lambda$. The assumption that $\lambda$ is a limit ordinal is required afterwards, to convert the model of $\TTT_\lambda$ into a model of $\mathrm{TST} + \text{typical ambiguity}$.]
\end{definition}

\begin{definition}
  \label {def:small}
  \uses{def:params}
  \leanok
  \lean{con_nf.small}
  We refer to sets of size smaller than $\kappa$ as \emph{small} [and all other sets as large].
  \end{definition}

\begin{definition}
\label {def:type-index}
\uses{def:params}
\leanok
\lean{con_nf.type_index}
We define a {\em type index} as an element of $\lambda^\bot := \lambda \cup \{-1\}$.
We define a {\em proper type index} as an element of $\lambda$.

In many ways, $-1$ should be viewed as a type index on the same footing as other elements of $\lambda$; but it frequently needs treating as a special case.

[In the formalisation, “$-1$” is referred to as $\bot$.  Should we consider following that in the text too?]
\end{definition}

\begin{definition}
\label{def:path}
\uses{def:type-index}
\leanok
\lean{con_nf.extended_index}
By a \emph{path}, we mean a path in the directed graph (aka quiver) $(\lambda^\bot,<)$; that is, a nonempty finite strictly increasing sequence of type indices $\alpha_0 < \cdots < \alpha_k$.  A path is \emph{proper} if its source (least element) is proper.

We will write paths as $A : \beta \pathto \alpha$.  We will write path concatenation and extension as $\gamma;A$, $A;B$, and similar.

These may be viewed as the arrows of the free category on $(\lambda^\bot,<)$.  We mostly avoid using this categorical packaging, to keep things elementary and avoid unnecessary dependencies; but we mention it occasionally in the blueprint, as $\Path(\lambda^\bot)$.

[There may be some terminological inconsistency: In places, paths are called \emph{extended type indices}, and are considered as sets rather than sequences; also, they are sometimes taken to be decreasing instead of increasing.]
\end{definition}

\section{Type $-1$: atoms, litters, and local cardinals}

We will define a function taking type indices $\alpha$ to sets $\tau_\alpha$ (type $\alpha$).

\newcommand{\Litter}{\mathcal{L}}
\newcommand{\NearLitter}{\mathcal{NL}}
\begin{definition}
\label{def:atoms-and-litters}
\uses{def:params}
\leanok
\lean{con_nf.atom,con_nf.litter}
Define $\Litter$ as $ (\lambda \cup \{-1\}) \times \lambda \times \mu$ and $\tau_{-1}$ as $\Litter \times \kappa$.

We refer to elements of $\tau_{-1}$ as \emph{atoms}.

By construction, atoms come partitioned into $\Litter$-many \emph{litters} of size $\kappa$,
\[ L_{\alpha,\beta,\xi} := \{((\alpha,\beta,\xi),x) \mid x \in \kappa \}.\]

The litters, in turn, come partitioned into $\lambda^2$-many classes of size $\mu$:
\[ X_{\alpha,\beta} := \{ (\alpha,\beta,\xi) \mid \xi \in \mu \}. \]

We generally identify litters $L_{\alpha,\beta,\xi}$ with their indices $(\alpha,\beta,\xi) \in \Litter$; for instance a quantification over “all litters” is formally a quantification over $\Litter$.
\end{definition}

The “atoms” of $\tau_{-1}$ are not quite atoms in a traditional sense — they do not appear as elements of the eventual structure — but they fulfil the same role of getting the set hierarchy off to a sufficiently non-trivial start.

\begin{definition}
\label {def:near-litter}
\uses{def:atoms-and-litters,def:small}
\leanok
\lean{con_nf.is_near_litter}
A \emph{near-litter} is a subset $N$ of $\tau_{-1}$ with small symmetric difference from some litter. This litter is necessarily unique, and we denote it by $N^\circ$.  We write $\NearLitter$ for the set of all near-litters.
\end{definition}

\begin{definition}
\label {def:local-cardinal}
\uses{def:near-litter}
\lean{con_nf.local_cardinal}
\leanok
For $i \in \Litter$, the $i$-th {\em local cardinal} $[L_i]$ is $\{N \subseteq \tau_{-1}:|N \symdiff L_i|<\kappa\}$.

For any near-litter $N$ (including litters), we write $[N]$ for the unique local cardinal that contains $N$. We introduce the notation $[N]^\circ$ for the litter belonging to the local cardinal of $N$, with the tacit need to prove that there is only one.

[Note: almost all roles played by local cardinals in the original text should be fulfilled in the formalisation by litter-indices $i \in \Litter$.]
\end{definition}

\begin{lemma}
\label {lem:small-diff-equiv}
\uses{def:small}
\leanok
\lean{con_nf.is_near.trans}
Note that $\Litter$ corresponds to the equivalence classes of an equivalence relation $\sim$ on near-litters, where $X \sim Y$ iff the symmetric difference $X \symdiff Y$ is small.
\end{lemma}

\begin{proof}
\leanok
This is left as an easy exercise for the reader.
\end{proof}

\begin{lemma}
\label {lem:count-near-litters}
\uses{def:near-litter}
\leanok
\lean{con_nf.mk_near_litter}
Because the cofinality of $\mu$ is $\geq \kappa$, there are $\mu$ near-litters.
\end{lemma}

\begin{proof}
\leanok
First, there are at least $\mu$ near-litters. Second, the equivalence induced by the symmetric difference with the $i$-th litter sends near-litters to sets of size strictly less than $\kappa$, hence of size strictly less than the cofinality of $\mu$. But there are at most (exactly, in fact) $\mu$ such sets, because by definition of cofinality they are all bounded in $\mu$ and $\sum_{\alpha < \mu} 2 ^ \alpha = \mu $ because $\mu$ is a strong limit cardinal.
\end{proof}

One might be concerned with the fact that if $\mu$ has cofinality $\kappa$, it might have more than $\mu$ subsets of size $\kappa$:  but it still has only $\mu$ subsets of size $<\kappa$, and that is what matters for counting the near-litters:  a near-litter is determined as the symmetric difference of a litter ($\mu$ of these) and a small subset (cardinality $<\kappa$) of $\tau_{-1}$ (which is of size $\mu$) and there are only $\mu$ small subsets of $\tau_{-1}$.  If the cofinality of $\mu$ were less than $\kappa$, the cardinal arithmetic pathology mentioned as of concern could come into play.

\section{Preliminaries: pretangles, structural permutations}

Before embarking on the large recursive construction of the eventual model, we set up some structures in advance which we will make use of during the main recursion.

We first define a big structure, which can be viewed as a model of TTT without extensionality, whose elements we call \emph{pretangles}.  In the main recursion, we will carve out our actual model of TTT as a substructure of \emph{tangles} within the pretangles.

\begin{definition}
  \label{def:pretangle}
  \uses{def:atoms-and-litters}
  \leanok
  \lean{con_nf.pretangle}
  Define the sets $\Pretangle_\alpha$ of \emph{$\alpha$-pretangles} inductively. $\Pretangle_{-1}$ is defined as $\tau_{-1}$. For $\alpha$ a proper type index, $\Pretangle_\alpha$ is defined as $\prod_{\beta < \alpha} \mathcal P(\Pretangle_\beta)$.
\end{definition}

We also set up a sequence of groups that act on pretangles; subgroups of these will later act on the tangles.

\begin{definition}
  \label{def:structural-perm-atoms}
  \uses{def:near-litter}
  \leanok
  \lean{con_nf.near_litter_perm}

  A \emph{structural $(-1)$-permutation} [aka a near-litter-perm; we should fix on one name or the other] is a permutation $\pi$ of $\tau_{-1}$, along with a permutation $\bar{\pi}$ of litters, such that for each litter $L$, $\pi``(L)$ is near to $\bar{\pi}(L)$ (in the sense that they have small symmetric difference).  Denote the group of these by $\Str_{-1}$.

  [In fact $\bar{\pi}$ is uniquely determined by $\pi$ — we could define this just as a subgroup of $\Sym(\tau_{-1})$.  But it’s convenient in formalisation to have the $\bar{\pi}$ component explicit.]

  $\Str_{-1}$ has obvious actions on atoms and near-litters.
\end{definition}

\begin{definition}
  \label{def:structural-perm}
  \uses{def:structural-perm-atoms}
  \leanok
  \lean{con_nf.struct_perm}
  For a \emph{proper} type index $\alpha$, the structural $\alpha$-permutations are the group $\Str_\alpha = \prod_{\beta < \alpha} \Str_\beta$.
\end{definition}

\begin{definition}
  \label{def:structural-perm-derivative}
  \uses{def:structural-perm}
  \leanok
  \lean{con_nf.struct_perm.derivative}
  Any path $A : \beta \pathto \alpha$ gives a group homomorphism $(-)_A : \Str_\alpha \to \Str_\beta$.

  Moreover, this is functorial: they make $\Str$ into a functor $\Path(\lambda^\bot)^\op \to \mathrm{Gp}$.

  [TODO: this should also depend on “paths”, but they aren’t yet explicitly in the blueprint.]
\end{definition}

\begin{definition}
  \label{def:allowable-perm-atoms}
  \uses{def:structural-perm-atoms}
  An \emph{allowable $(-1)$-permutation} is just a structural $(-1)$-permutation. We denote the group of these by $\All_{-1} = \Str_{-1}$.  (Later we will define $\Str_\beta$ as a proper subgroup of $\All_\beta$, for higher $\beta$.)
\end{definition}

\begin{definition}
  \label{def:support-condition}
  \uses{def:near-litter,def:atoms-and-litters} % TODO: add def:paths upstream, and add it here.
  \lean{con_nf.support_condition}
  \leanok
  Let $\alpha$ be a proper type index. An \emph{$\alpha$-support-condition} (or just \emph{$alpha$-condition}) is a pair $(x,A)$, where $A$ is a path from $-1$ to $\alpha$ (aka an extended type index) and $x$ is either an atom or a near-litter.

  Type-theoretically, $\Cond_\alpha := (\tau_{-1} + \NearLitter) \times \mathrm{Path}(-1,\alpha)$.

  [It would suffice to use just litters here instead of near-litters; they give an equivalent notion of support, as shown later (“replacing near-litters with litters”).  That makes a few things simpler; but using near-litters lets us talk about the action, Def.~\ref{def:support-condition-action}, which seems algebraically cleaner.]
\end{definition}

\begin{definition}
\label{def:support-condition-action}
\uses{def:structural-perm-derivative,def:support-condition}
\lean{con_nf.con_nf.support_condition.mul_action_2}
\leanok
Structural permutations act on support conditions.
\end{definition}

\begin{definition}
\label{def:support}
\uses{def:support-condition}
\lean{con_nf.potential_support}
\leanok
Let $\alpha$ be a proper type index. An $\alpha$-support is a small set of $\alpha$-support-conditions.  (A little more pedantically, one could call these something like “potential small supports”: they become actual supports once they support some element.)

[NOTES for formalisation: Well-orderings are assumed here in some version of Randall’s note, but they almost certainly aren’t wanted in the basic definition of supports, as used in phase 1. Strong supports, as used in phase 2, are probably better viewed as a separate notion: a more elaborate data structure that can be used to “present” a support in a particularly good way.]
\end{definition}

\begin{definition}
\label{def:support-of}
  \uses{def:support,def:support-condition-action}
  \lean{con_nf.support}
  \leanok
  Suppose $\varphi : H \to \Str_\alpha$ is any group homomorphism, and $\tau$ is a set equipped with an $H$-action.

  Given $x \in \tau$ and $S$ any set of $\alpha$-support conditions, say \emph{$S$ supports $x$} if every $\pi \in H$ that fixes every element of $S$ also fixes $x$.

  A \emph{support for $x$} is a support (i.e.\ a \emph{small} set of conditions) that supports $x$. [Should we try to always say “small support” to avoid ambiguity?]

  We say $x$ is \emph{symmetric} if it has some small support.
\end{definition}

\begin{lemma}
  \label{lem:count-supports}
  \uses{def:support-of}
  \lean{con_nf.mk_support_le}
  \leanok
  Because the cofinality of $\mu$ is $\geq \kappa$, there are $\mu$ potential supports, and therefore at most $\mu$ supports for each $x \in \tau$.
\end{lemma}
\begin{proof}
  \uses{lem:count-near-litters}
  \leanok
\end{proof}

\chapter{Phase 1: The model construction} \label{ch:model-construction}

In this chapter, we give almost the entire construction of the structure which will (eventually) be a model of tangled type theory.

This should be read as an attempt at a recursion over the levels $\alpha \in \lambda$ of the structure.  We start by describing what data should exist at each level of the structure; then this section consists mostly of showing that given this data at each level $\beta < \alpha$, we can construct \emph{almost} all this data at level $\alpha$.

Unfortunately, one piece of the data is harder to propagate --- essentially just the fact that the set of tangles at level $\alpha$ is of size $< \mu$.  Proving this is not only lengthy, but also requires a more complex recursive assumption: not just data at each earlier level, but also information about how they interact between different levels.  This difference in the recursive assumptions is the motivation for the phase separation.

\section{Inductive assumptions}

For now, we group the data assumed at each level, according to which constructions it will be needed for.

\begin{definition}
  \label{def:tangle-data}
  \uses{def:support-of,def:pretangle}
  \lean{con_nf.phase_1}

  Fix a proper type index $\alpha$.  Then \emph{tangle data at $\alpha$} consists of:
  \begin{enumerate}
    \item a group $\All$ (whose elements we call \emph{allowable permutations}), with a map $\varphi : \All \to \Str_\alpha$;
    \item a set $\tau$ (whose elements we call \emph{tangles}), equipped with an $\All$-action;
    \item a map $j$ (\emph{typed near-litters}) from near-litters to $\tau$, equivariant with respect to the $\All$-action on near-litters induced by $\All \to \Str_{\alpha} \to \Str_{-1}$;
    \item a map $k$ (\emph{typed singletons}) from $\tau_{-1}$ to $\tau$, again $\All$-equivariant w.r.t.\ the induced action on $\tau_{-1}$;
    \item for each $x \in \tau$, a small set $S_x$ of $\alpha$-support-conditions that supports $x$ under the $\All$-action (a \emph{designated support} for $x$);
    \item an injection $\iota : \tau \to \mu$, satisfying the following conditions:
    \begin{enumerate}
      \item each typed litter $j(L)$ precedes the typed singletons of all its elements $a \in L$ --- explicitly, $\iota(j(L)) < \iota(k(a))$;

      \item each typed near-litter $k(N)$ which is not a litter comes later than its (typed) litter $j(N^\circ)$, and after (the typed singletons of) all elements of $N \symdiff N^\circ$;

      \item for each $x$ in $\tau_\alpha$ that is not a typed litter or singleton, $x$ comes later than all of its designated support -- explicitly, for each $(a,A)$ or $(N,A)$ in $S_x$, we must have $\iota_\alpha(j(N)), \iota_\alpha(k(a))<\iota_\alpha(x)$.
    \end{enumerate}
    [Note: to see these conditions are not unreasonable, note that each $x \in \tau$ has $<\mu$ many things that it must come after, and that the chains of these constraints are of depth at most 4: litters $<$ atoms $<$ other near-litters $<$ everything else.  This is said more carefully in \cref{lem:position-functions-propagate} below.]
    \item {[Optionally: An injection $\tau \to \Pretangle_\alpha$, equivariant with respect to the induced $\All$-action.  This may or may not be needed, depending on how the phase 2 data is organised.]}
  \end{enumerate}

  By \emph{core tangle data}, we will mean just $\All$, $\varphi$, $\tau$, and the $\All$-action on $\tau$ as above.  By \emph{incomplete tangle data}, we will mean all the above data except for the position functions $\iota$ and their properties.

  When we assume this data at multiple levels, we will refer to the components $\tau_\beta$, $\All_\beta$, and so on, and call their elements $\alpha$-tangles, etc.
\end{definition}

There is standard core tangle data at level $-1$, and also the position function $\iota_{-1} : \tau_{-1} \to \mu$.  We will often refer to this uniformly with assumed tangle data at other levels: for instance, if we assume tangle data at all \emph{proper} levels $\beta < \alpha$, we may then refer to $\tau_\beta$ for all levels $\beta < \alpha$: for $\beta$ proper, this means the tangles of the assumed tangle data, while for $\beta = -1$ it means the fixed set of atoms $\tau_{-1}$.

\section{Phase 1a: Set codes and alternative extensions}

In most of the following few constructions, we will fix a proper type index $\alpha$ and assume we have tangle data given for all proper $\beta < \alpha$. (In fact some results --- in particular, the $f$-maps, $A$-maps and their properties --- only need to refer to the data at certain earlier levels.)

\begin{definition}
\label {def:code}
\uses{def:tangle-data}
\lean{con_nf.code}
\leanok
An $\alpha$-code is a triple $(\alpha,\gamma,G)$ where $\gamma<\alpha$ and $G \subseteq \tau_\gamma$. [The original set-theoretic implementation includes the $\alpha$, to keep codes at different levels disjoint.  In the type-theoretic implementation, the first component $\alpha$ is unnecessary.]
\end{definition}

\begin{definition}
\label {def:f-map}
\uses{def:tangle-data}
\lean{con_nf.f_map}
\leanok
We define, for all $\beta,\gamma < \alpha$, with $\gamma$ proper, a map $f_{\beta,\gamma}$ from $\tau_\beta$ to $X_{\beta,\gamma} \subseteq \mathrm{Litter}$, as follows.

For $x \in \tau_\beta$, $f_{\beta,\gamma}(x)$ is the litter $N^\circ$ of the minimal near-litter $N$ (under the ordering induced by $\iota_\beta \circ j_\beta : \NearLitter \to \tau_\beta \to \mu$) such that:
\begin{itemize}
  \item $N^\circ\in X_{(\beta,\gamma)}$, i.e. $N^\circ = L_{(\beta,\gamma,i)}$, for some $i$;
  \item for each nearby near-litter $M \sim N$, $\iota_\gamma(j_\gamma(M)) >\iota_\beta(x)$;
  \item $[N] \neq f_{\beta,\gamma}(y)$, for each $y <_\beta x$.
\end{itemize}

[This can be decomposed slightly at both ends.  Firstly, since we know that $f_{\beta,\gamma}(x) = (\beta,\gamma,\chi)$ for some $\chi$, we could take the output just to be the component $\chi \in \mu$, and turn it into a litter later.  Secondly, $f_{\beta_\gamma}(x)$ depends on $x$ essentially just via its position $\iota_\beta(x) \in \mu$, so we could start by defining a function $g_{\beta,\gamma} : \mu \to \mathrm{Litter}$, and then take $f_{\beta,\gamma}$ as the composite $g_{\beta,\gamma} \circ \iota_\beta$.  I don’t think these will really make a difference either way, though.]

[Notice that this only depends on a small fragment of the tangle data at $\beta$ and $\gamma$. In particular, it doesn’t depend on $\alpha$ nor on the tangle data at other levels. In the formalisation, it would be good to avoid it depending on more than it needs.]
\end{definition}

\begin{lemma}
  \label{lem:f-map-properties}
  \uses{def:f-map}
  \lean{con_nf.f_map_injective}
  \leanok
  The maps $f_{\beta,\gamma}$ satisfy:
  \begin{enumerate}
  \item each $f_{\beta,\gamma}$ is injective;
  \item their images are disjoint, for all different pairs $(\beta,\gamma)$;
  \item each $f_{\beta,\gamma}$ is “position-raising”: $\iota_\gamma(j_\gamma(N)) > \iota_\beta(x)$, for any near-litter $N$ near to the litter $L_{(\beta,\gamma,f_{\beta,\gamma}(x))}$.
  \end{enumerate}
\end{lemma}
\begin{proof}\leanok\end{proof}

\begin{definition}
\label {def:a-map}
\uses{def:f-map,def:code,def:local-cardinal}
\lean{con_nf.A_map}
\leanok
Let $\gamma$ be a type index (not necessarily proper) below $\alpha$.

For any code $(\alpha,\gamma,G)$, with $\delta$ a proper type index below $\alpha$ and distinct from $\gamma$, we define
$A_\delta(\alpha,\gamma,G)$ as
$$(\alpha,\delta,\{ j_\delta(N) \mid N \in \NearLitter,\, N \sim f_{\gamma,\delta}(g),\, g \in G \})$$
if the maps $f_{\gamma,\delta}$ are considered as valued in litters, or
$$(\alpha,\delta,\{ j_\delta(N) \mid N \in f_{\gamma,\delta}(g),\, g \in G \})$$
if they are taken as valued directly in local cardinals.

We say that a code $c$ \emph{leads to} a code $d$ if $d$ is the image of $c$ under some A-map. We denote this $c \rightsquigarrow d$.

(Here $j_\delta(N)$ is the “typed near-litters” map for level $\delta$, assumed in the tangle data.)

[For the formalisation, each individual $A_\delta$ is probably best represented as a function $\mathcal{P}(\tau_\gamma) \to \mathcal{P}(\tau_\delta)$, rather than on “codes of the form $(\alpha,\gamma,G)$…”.  Also it could — and perhaps should, for flexibility later — have parameters just “$\gamma$, $\delta$, and their tangle data”, rather than “$\alpha$, tangle data everywhere below $\alpha$, and $\gamma,\delta < \alpha$”.]
\end{definition}

\begin{lemma}
\label {lem:a-map-properties}
\uses{def:a-map}
\lean{con_nf.A_map_injective}
\leanok
\begin{enumerate}
\item Each $A_\delta$ is injective on nonempty codes.
\item The ranges of $A_\delta$ are disjoint for different $\delta$.
\end{enumerate}

NB: The disjointness of ranges depends on excluding the empty set --- either from the domains of the $A_\delta$ from the start, or else in the statement of this lemma.
\end{lemma}
\begin{proof}
\uses{lem:f-map-properties}
\leanok
\item Each $f_{\gamma,\delta}$ is injective, and $f_{\gamma,\delta}$ have disjoint images for different $\gamma$.
\item The ranges of $f_{\gamma,\delta}$ are disjoint for different $\delta$.
\end{proof}

\begin{lemma}
\label{lem:a-map-wf}
\uses{def:a-map}
\lean{con_nf.A_map_rel_well_founded}
\leanok
The relation $c \rightsquigarrow d$ on codes (“$c$ leads to $d$ under some $A$-map”) is well-founded.
\end{lemma}

\begin{proof}
\uses{lem:a-map-properties}
\leanok
  Consider the map $m$ from codes to $\mu$ sending $(\alpha,\gamma,X)$ to $\min \iota_\gamma``X$, where $\iota_\gamma : \tau_\gamma \to \mu$ is the position function assumed in the tangle data.

  The definition of the functions $A_{\delta,\gamma}$ and the fact that $\iota f_{\gamma,\delta}(x) > \iota x $ ensure that $j(\alpha,\gamma,X) < j(A_\delta(\alpha,\gamma,X))$, for all suitable $\gamma,\delta,X$.

  In other words, if $c \rightsquigarrow c'$, then $m(c) < m(c')$ in $\mu$.  It follows that $\rightsquigarrow$ is well-founded.
\end{proof}

\begin{definition}
\label {def:code-parity}
\uses{def:a-map}
\lean{con_nf.code.is_even}
\leanok
A code is \emph{even} if it only leads to odd codes. A code is \emph{odd} if it leads to some even code.

Note: This exactly says that even codes are the losing positions of the game whose states are codes
and possible moves are taking the preimage under some A-map.
\end{definition}

\begin{lemma}
\label {lem:code-parity-properties}
\uses{def:code-parity}
\lean{con_nf.code.is_even_or_is_odd}
\leanok
\begin{enumerate}
\item All codes are even or odd.
\item An odd nonempty code only leads to even codes.
\end{enumerate}
\end{lemma}
\begin{proof}
\uses{lem:a-map-wf}
\leanok
\begin{enumerate}
\item $\rightsquigarrow$ is well-founded.
\item An odd nonempty code leads to an even code and the A-maps are injective on nonempty codes and have disjoint ranges.
\end{enumerate}
\end{proof}

\begin{definition}
\label {def:code-equiv}
\uses{lem:code-parity-properties}
\lean{con_nf.code.equiv}
\leanok
We define an equivalence relation $\equiv_\alpha$ on $\alpha$-codes inductively:
\begin{enumerate}
\item For every code $c$, $c \equiv_\alpha c$.
\item If $(\alpha,\gamma,G)$ is even and $\gamma \neq \delta$, then $(\alpha,\gamma,G) \equiv_\alpha A_\delta (\alpha,\gamma,G)$ and $A_\delta (\alpha,\gamma,G) \equiv_\alpha (\alpha,\gamma,G)$.
\item If $(\alpha,\gamma,G)$ is even and $\gamma \neq \delta, \varepsilon$, then $A_\delta (\alpha,\gamma,G) \equiv_\alpha A_\varepsilon (\alpha,\gamma,G)$.
\end{enumerate}

This is reflexive and symmetric by definition, and transitive by using the properties of code parity.
\end{definition}

\begin{lemma}
\label{lem:code-equiv-properties}
\uses{def:code-equiv}
\leanok
\lean{con_nf.code.equiv.unique}
Under $\equiv_\alpha$, each code is equivalent to
\begin{enumerate}
\item exactly one even code
\item exactly one code of extension $\gamma$ for all $\gamma \ne -1$, $\gamma < \alpha$
\item at most one code of extension $-1$
\end{enumerate}
\end{lemma}
\begin{proof}
\leanok
\end{proof}

\begin{definition}
  \label{def:semi-tangle}
  \uses{lem:code-equiv-properties}
  \lean{con_nf.semitangle}
  \leanok
  An \emph{$\alpha$-semi-tangle} is an element $x$ of $\prod_{\beta < \alpha}\mathcal P(\tau_\beta) \times (\alpha + \mathcal P(\tau_{-1}))$, whose components we denote $x_\beta$, such that:
  \begin{itemize}
    \item if $x_{-1}$ is some $\beta < \alpha$, then $(\alpha,\beta,x_\beta)$ is a representative code, and for each other $\gamma$, $A_{\beta,\gamma}(\alpha,\beta,x_\beta) = (\alpha,\gamma,x_\gamma)$;
    \item if $x_{-1}$ is a set of atoms, then $(\alpha,-1,x_{-1})$ is a representative code, and for each other $\gamma$, $A_{-1,\gamma}(\alpha,-1,x_{-1}) = (\alpha,\gamma,x_\gamma)$;
  \end{itemize}

  [Note that these are intermediate between “pretangles” and “tangles”.  Also note that — as with pretangles — we probably don’t need the “preferred extension” component.]

  [Actually it’s probably simpler to go back to representing these as representative codes for now, and just define here the components $x_\beta$, for later embedding them into pretangles.  It’s only in phase 2 that the embedding into pretangles will really become helpful!]
\end{definition}

\begin{definition}
\label{def:ttt-membership}
\uses{def:semi-tangle}
\lean{con_nf.semitangle.mem}
\leanok
  Membership relations of $\alpha$-semi-tangles, for the intended model of tangled type theory, can now be defined as follows: for each proper type index $\beta < \alpha$, and $x \in \tau_\beta$, and each $\alpha$-semi-tangle $y \in \tau_\alpha$, say $x \in_{TTT} y$ just if $x \in y_\beta$.
\end{definition}

This would be enough to enforce extensionality, but something much more radical needs to be done to make all this work, as we are assuming the existence of the maps $\iota_\beta$, which witness that all the types are of cardinality no greater than $\mu$.  There must therefore be a very strong restriction on which sets can appear as components of tangles.

This all cries out for a Theorem which should be here and which I left implicit in the original text.

\begin{theorem}
\label {thm:extensionality}
\uses{def:ttt-membership}
\lean{con_nf.semitangle.ext}
\leanok
For all proper type indices $\beta < \alpha$, $\beta$-tangles $x$, and $\alpha$-semitangles $y$, the following (nearly-obviously equivalent) statements hold:
\begin{itemize}
  \item if for all $z \in \tau_\beta$, $(z \in_{\tt TTT} x \leftrightarrow z \in_{\tt TTT} y)$, then $x=y$;
  \item if $x_\beta = y_\beta$, then $x=y$.
\end{itemize}
\end{theorem}
\begin{proof}\leanok\end{proof}

\section{Phase 1b: Actual tangles: the model definition}

  For the subsequent constructions of this section, we assume we are given tangle data for all $\beta < \alpha$.

\begin{definition}
\label {def:semiallowable-perm}
\lean{con_nf.semiallowable_perm}
\leanok
\uses{def:tangle-data}
  A \emph{semi-allowable permutation} at level $\alpha$ is a family of allowable pemutations at all lower levels (including $-1$), $(\pi_\beta)_{\beta < \alpha} \in \prod_{\beta < \alpha} \All_\beta$.
\end{definition}

\begin{definition}
\label{def:code-action}
\uses{def:code,def:semiallowable-perm}
\lean{con_nf.semiallowable_perm.mul_action_code}
\leanok
Semi-allowable permutations act on $\alpha$-codes.
\end{definition}

\begin{definition}
  \label{def:allowable-perm}
  \uses{def:code-action,def:code-equiv}
  \lean{con_nf.allowable_perm}
  \leanok
  An \emph{allowable permutation} is a semi-allowable permutation which preserves $\equiv_\alpha$: for all $\alpha$-codes $X,Y$, $X \equiv_\alpha Y \leftrightarrow \pi(X) \equiv_\alpha \pi(Y)$.
\end{definition}

\begin{lemma}
\label {lem:coherence-unpacked}
\uses{def:allowable-perm}
\lean{con_nf.allowable_perm.coherence}
\leanok
A semi-allowable permutation $\pi$ is allowable just if
$$f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``f_{\gamma,\delta}(g)^\circ].$$
holds for all $f_{\gamma,\delta}$ with $\gamma,\delta<\alpha$, and all $g \in \tau_\gamma$.
\end{lemma}

\begin{proof}
\leanok
This is discussion supporting the preceding lemma. The proof is given more carefully in Randall’s more recent version of the note.

The coherence condition can be unpacked.
$$(\beta,\gamma,\{g\}) \equiv_\beta (\beta,\delta,\{(\delta,-1,N):N \in f_{\gamma,\delta}(g)\})$$(where $\delta\neq \gamma$).  Thus we expect
$$\pi(\beta,\gamma,\{g\}) \equiv_\beta \pi(\beta,\delta,\{(\delta,-1,N):N \in f_{\gamma,\delta}(g)\})$$
that is,
$$(\beta,\gamma,\{\pi_\gamma(g)\}) \equiv_\beta (\beta,\delta,\{(\delta,-1,(\pi_\delta)_{-1}``N):N \in f_{\gamma,\delta}(g)\})$$
so $f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``L]$, where $f_{\gamma,\delta}(g)=[L]$.

Recalling the notations $N^\circ$ for the litter with small symmetric difference from the near-litter $N$, we can write this $$f_{\gamma,\delta}(\pi_\gamma(g)) = [(\pi_\delta)_{-1}``f_{\gamma,\delta}(g)^\circ].$$

It is straightforward to show that this condition is equivalent to the coherence condition.  Notice that $\pi_\gamma$ imposes some restrictions on $\pi_\delta$, but only on the way it acts on certain typed near-litters (and of course there are reciprocal relations between $\pi_\delta$ and $\pi_\gamma$).
\end{proof}

\begin{lemma}
\label{lem:parity-action}
\lean{con_nf.code.is_even.smul}
\leanok
The action of allowable permutations on codes preserves parity.
\end{lemma}
\begin{proof}
  \uses{lem:coherence-unpacked,lem:code-equiv-properties}
\leanok
This should be straightforward.  A target should be the equation $\pi(A_\gamma(X)) = A_\gamma(\pi(X))$ for any allowable permutation $\pi$ and code $X$ for which $\pi_\gamma$ is defined.
\end{proof}

\begin{definition}
\label{def:semi-tangle-action}
\uses{def:semi-tangle,lem:parity-action}
\lean{con_nf.allowable_perm.mul_action_semitangle}
  Allowable permutations act on semi-tangles.
\end{definition}

\begin{definition}
\label{def:tangle}
\uses{def:semi-tangle-action,def:support-of}
\lean{con_nf.new_tangle}
\leanok
We take the set of $\alpha$-tangles, $\tau_\alpha$, to be the set of \emph{symmetric} $\alpha$-semi-tangles under the action of allowable permutations; that is, tangles that are supported by some small $\alpha$-support $S$,.
\end{definition}

\begin{lemma}
\label{lem:supportedness-equiv}
\uses{def:support-of,def:allowable-perm}
\lean{con_nf.code.equiv.symmetric_iff}
\leanok
If $X \subseteq \tau_\beta$, $Y \subseteq \tau_\gamma$, and $(\alpha,\beta,X) \equiv_\alpha (\alpha,\gamma,Y)$, then (under the action of allowable permutations on codes) a set $S$ of conditions supports $\beta$ if and only if it supports $\gamma$.  In particular,  $(\alpha,\beta,X)$ has some small support if and only if $(\alpha,\gamma,Y)$ does.
\end{lemma}

\begin{proof}
\leanok
  Immediate from the definition of allowable permutations.
\end{proof}

We state a couple of easy lemmas which are things we assumed in the inductive data, which must be shown to carry forward to $\tau_\alpha$.  There are more obligations of this sort which are harder to discharge, which will be provided in phase 2.

\begin{lemma}
\label{def:typed-near-litter}
\uses{def:tangle}
\lean{con_nf.typed_near_litter}
\leanok
Any code $(\alpha,-1,N)$, where $N$ is a near-litter, gives an element of $\tau_\alpha$.
\end{lemma}

\begin{proof}
\uses{lem:supportedness-equiv}
This code is obviously even [though this isn’t really necessary, thanks to Lemma~\ref{lem:supportedness-equiv}] and it is supported by a singleton condition, a suitable decorated version of $N$.
\end{proof}

\begin{lemma}
\label{def:typed-singleton}
\uses{def:tangle}
\lean{symmetric_singleton}
\leanok
For any symmetric $b \in \tau_\beta$, $(\alpha,\beta,\{b\}) \in \tau_\alpha$. In particular, this works for each atom $a \in \tau_{-a}$.
\end{lemma}

\begin{proof}
Take a $\beta$-support for $b$, and extend all the paths in it at the top by the step $\beta < \alpha$.  At level $-1$, any atom is clearly supported by its own singleton.

[This should be easy if we defined paths by induction from the top; if we have paths in reverse, it may need lemmas on how derivatives interact with extension at the top.  Or they might follow from functoriality of derivatives?]
\end{proof}

\begin{lemma}
\label {lem:small-subsets-closure}
\uses{def:tangle}
\lean{con_nf.symmetric_set}
\leanok
It should also be evident that $(\alpha,\beta,B)$ will always be symmetric if $|B|<\kappa$ [take the union of the $\beta$-supports of elements of $B$ and add $\alpha$ to all the second components of elements of this union]:  all small subsets of a type are realized in each higher type.
\end{lemma}

\begin{lemma}
  \label{lem:tangle-action}
  \uses{def:tangle}
  \lean{con_nf.allowable_perm.mul_action_new_tangle}
  \leanok
  The action of $\alpha$-allowable permutations on semi-tangles restricts to an action on tangles.  Explicitly, if an $\alpha$ semi-tangle $x$ is symmetric, then so is $\pi x$ for any $\alpha$-allowable permutation $\pi$.
\end{lemma}
\begin{proof}
  The algebra of group actions should show reasonably easily that if $\pi$ is an $\alpha$-allowable permutation and $X \in \tau_\alpha$ has $\alpha$-support $S$, then $\pi(X)$ has $\alpha$-support $\pi``S$.
\end{proof}

The obligation to prove that $\tau_\alpha$ is of size $\mu$ remains outstanding.  And of course we want to prove that the entire structure is a model of tangled type theory with $\tau_\gamma$ as type $\gamma$ for each $\gamma<\lambda$ and $\in_{\tt TTT}$ as its membership relation.

There is lots to be proven, but that is the entire description.

\section{Phase 1c: the embedding into pretangles}

[Note: this may not eventually be needed, depending on how the “coherence” in phase 2 is assumed.]

For the subsequent constructions of this section, we assume we are given tangle data for all $\beta < \alpha$.

\begin{definition}
  \label{def:embedding-into-pretangles}
  \uses{def:semi-tangle,def:tangle-data}
  \lean{con_nf.new_tangle.to_pretangle}
  \leanok
  There is an evident injection $\tau_\alpha \to \Pretangle_\alpha$ (where $\tau_\alpha$ is constructed from the given tangle data).  Moreover, this commutes with the $\All_\alpha$-action.
\end{definition}

\section{Review}

Overall, we have now shown:

\begin{definition}
  \label{def:tangle-data-propagates}
  \uses{def:embedding-into-pretangles,def:typed-near-litter,def:typed-singleton,lem:tangle-action}
  For a proper type index $\alpha \in \lambda$, given tangle data at all levels $\beta < \alpha$, then the constructions above provide \emph{most} components of tangle data at level $\alpha$ — everything except for the embedding $\iota_\alpha : \tau_\alpha \to \mu$ and its properties.

  [Note that to treat this as a \emph{definition}, in particular of the “designated supports” component, we are implicitly invoking the axiom of choice --- a priori we only know that there \emph{exists} some support for each new tangle.]
\end{definition}

\newpage

\chapter{Phase 2: Constraining the number of tangles}

In this phase, we give the three hard theorems about the constructions of phase 1: strengthening supports, freedom of action, and constraining the number of tangles.

These meet the major technical difficulty of the recursion: For each topic in phase 2, we need to assume something along the lines of tangle data at all earlier levels, and suitable connections between them”.  The tricky bit is structing the “…suitable connections…” cleanly.

The greediest approach, which can’t fail to work, is to assume some form of “at every level, the tangle data is equal to what is constructed from the data at earlier levels, by the constructions of phase 1”.  This was used in previous versions, as “coherent tangle data”.  However, this is somewhat awkward to work with in formalisation.  A more cleanly-structured version is given by “freedom of action contexts”, \cref{def:foa-context}, which axiomatise just as much of the connection between earlier levels as the recursive construction needs to know.

\section{Freedom of action context}

\begin{definition}
  \label{def:foa-context}
  \uses{def:tangle-data}
  A \emph{freedom of action context} at a proper type index $\alpha$ consists of:

  \begin{enumerate}
  \item for every $\beta$ and path $A : \beta \to \alpha$, core tangle data $\All_A$, $\tau_A$ etc at $\beta$;
  \item for each such $\beta$, $A$, when $A$ a \emph{proper} path (equivalently, when $\beta < \alpha$), \emph{full} tangle data extending the given core data;
  \item for $A : \beta \to \alpha$ and $\gamma < \beta$, a \emph{derivative} map $(-)_\gamma : \All_{A} \to \All_{\gamma;A}$, commuting with the maps $\All_\bullet \to \Str_\bullet$ and $(-)_{\gamma} : \Str_\beta \to \Str_\gamma$.
  \end{enumerate}

  Notes:
  \begin{enumerate}
  \item The name “freedom of action context” is very much a placeholder; it would be good to find a better name.
  \item This can be repackaged several equivalent ways.  For instance, the quantification over paths could be re-grouped as “for each $\beta < \alpha$ and $A : \gamma \to \beta$, full tangle data at $\gamma$; and core tangle data at $\alpha$”.  This would avoid needing to say “full tangle data extending the given core data”, but would make access to the core data less uniform.
  \item Viewed categorically, the assumed maps make $\All$ into a functor on the slice category $(\Path (\lambda,<)/\alpha)^\op \to \mathrm{Gp}$, making the maps $\All \to \Str$ a natural transformation.
  \item The motivation for assuming just “core data” at $\alpha$ itself is that for the main constructions, we’ll be working in the inductive step of the recursion where we’re assuming the data is already available at lower levels, and by the constructions of phase 1, we can assume some but not all of it is available at the “current level”.
  \item The motivation for parametrising the lower data not just by levels but by paths is so that when we synthesise this data at $\alpha$ from similar data at each $\beta < \alpha$, no coherence between the given data is required.
  \end{enumerate}
\end{definition}

\begin{definition}
  \label{def:restrict-foa-context}
  \uses{def:foa-context}
  Given a freedom of action context at $\alpha$ and a path $A : \beta \to \alpha$, we can restrict the context along $A$ to get a freedom of action context at $\beta$.
  %
  Moreover, this is functorial in $A$.
\end{definition}

\begin{definition}
  \label{def:synthesise-foa-context}
  \uses{def:foa-context,def:tangle-data-propagates}
  Given $\alpha \in \lambda$, and a freedom of action context at each $\beta < \alpha$, together with extensions of their top-level core tangle data to full tangle data at each $\beta < \alpha$, there is a \emph{synthesised} freedom of action context at $\alpha$, with its top-level core tangle data given by the constructions of phase 1.
\end{definition}

\section{Freedom of action [new version]}

A key technical lemma, used both for counting tangles and for proving that they satisfy comprehension, is the proof that allowable permutations act freely, in a suitable sense.

Roughly, any consistent and locally small specification of values of derivatives of an allowable permutation at elements of type $-1$ can be realized.

In order to state the theorem precisely, we must first set up a framework for discussing partial specifications of structural/allowable permutations.

\begin{definition}
  \label{def:binary-condition}
  \uses{def:support-condition}
  Let $\alpha$ be a proper type index. Recall that an \emph{$\alpha$-condition} is a pair $(x,A)$, where $A$ is a path from $-1$ to $\alpha$ (aka an extended type index) and $x$ is either an atom or a near-litter; the set of these was denoted $\Cond_\alpha := (\tau_{-1} + \NearLitter) \times \mathrm{Path}(-1,\alpha)$.

  A \emph{binary condition} similarly consists of a pair of atoms or of near-litters, together with a path from $-1$ to $\alpha$:
  \[ \BiCond_\alpha := (\tau_{-1}^2 + \NearLitter^2) \times \mathrm{Path}(-1,\alpha).\]
\end{definition}

\begin{definition}
  \label{def:condition-functoriality}
  \uses{def:binary-condition}
  Paths act covariantly on binary conditions.  Explicitly, a path $A : \beta \to \alpha$ induces a map $(-)A \BiCond_\beta \to \BiCond_\alpha$, defined by $(x,B)A := (x,BA)$; and this preserves identities and composition.

  Taking inverse images under these maps, paths act contravariantly on sets of binary conditions: a path $A : \beta \to \alpha$ induces $(-)_A : \pow(\BiCond_\alpha) \to \pow(\BiCond(\beta))$, given by $\sigma_A := \{ (x,y,B) \mid (x,y,BA) \in \sigma \}$.
\end{definition}

\begin{definition}
  \label{def:conditions-from-perm}
  \uses{def:binary-condition}
  A binary condition $(x,y,A)$ is viewed as representing the condition “$\pi_A(x) = y$”.  Any $\alpha$-structural permutation $\pi$ thus induces a set of binary conditions, its \emph{graph}, $\{ (x,y,A) \in \BiCond_\alpha \mid \pi_A(x) = y \}$.  This gives an evident embedding $\Str_\alpha \to \pow(\BiCond_\alpha)$; we will notationally identify structural permutations with their graphs.

  We say that a structural permutation $\pi$ \emph{extends} a set of binary conditions $\sigma$ if $\sigma \subseteq \pi$, viewing $\pi$ as its graph.  More generally, given any group with a map $\varphi : G \to \Str$ (e.g.\ the allowable permutations of some tangle data), we say $\pi \in G$ extends a set of binary conditions $\sigma$ if $\sigma \subseteq \varphi(\pi)$.
\end{definition}

\begin{proposition}
  \label{prop:conditions-from-perm-restriction}
  \uses{def:conditions-from-perm,def:condition-functoriality}
  This identification of permutations respects the actions of paths.  That is, given a structural permutation $\pi$, the graph of the derivative $\pi_A$ is precisely the restriction along $A$ of the graph of $\pi$ (as our notational identification suggests).
\end{proposition}

\begin{definition}
  \label{def:condition-dom-rge}
  \uses{def:binary-condition}
  Previously, we viewed $\alpha$-conditions $(x,A) \in \Cond_\alpha$ as representing the conditions $\pi_A(x) = x$, as used in supports (and under this view we could identify them with the binary conditions $(x,y,A)$).  In this section, we will more often view them as elements of the domain or range of a set of binary conditions.  Precisely, for a set $\sigma$ of binary conditions, we take $\dom \sigma := \{ (x,A) \mid (x,y,A) \in \sigma \}$, and similarly $\rge \sigma := \{ (y,A) \mid (x,y,a) \in \sigma \}$.

  By a slight abuse of terminology, when working with sets of conditions, we will often say “litter” to mean “litter-with-path”, i.e.\ “condition of the form $(L,A)$”, and similarly for near-litter” and “atom”.
\end{definition}

\begin{definition}
  \label{def:condition-total-1-1}
  \uses{def:condition-dom-rge}
  We extend standard properties of binary relations to sets of binary conditions:

  Say a set of binary conditions $\sigma \subseteq \BiCond_\alpha$ is \emph{total} if its domain is $\Cond_\alpha$; co-total if its range is; and one-to-one if whenever $(x,y,A)$ and $(x',y',A')$ are in $\sigma$, $x = x'$ if and only if $y = y'$.

  The \emph{dual} $\sigma^{-1}$ of a set of binary conditions is $\{ (y,x,A) \mid (x,y,A) \in \sigma \}$.
\end{definition}

\begin{proposition}
  \label{prop:total-1-1-gives-perm}
  \uses{def:condition-total-1-1,def:conditions-from-perm}
  A set of binary conditions is the graph of a structural permutation precisely if it is one-to-one and total.

  (NOTE: this may not be explicitly needed, but it is helpful to know, and should be a good warmup and definition-test ahead of the main freedom of action theorem, in particular \cref{prop:total-allowable-partial-perm-actual}.)
\end{proposition}

\begin{proposition}
  \label{prop:total-1-1-restriction}
  \uses{def:condition-total-1-1,def:condition-functoriality}
  If a set of $\alpha$-conditions $\sigma$ is total (resp.\ co-total, 1-1) then so is its restriction $\sigma_A$ for any path $A : \beta \to \alpha$.
\end{proposition}

\begin{definition}
  \label{def:flexible-condition}
  \uses{def:foa-context}
  Given a freedom of action context at a proper type index $\alpha$, a \emph{flexible litter} is a condition $(L,A)$, with $L$ a litter, such that $L$ is not in the image of any of the $f$-maps $f^A_{\gamma,\delta}$ (for any $\gamma,\delta < \beta \pathto^A \alpha$).
\end{definition}

\begin{definition}
  \label{def:allowable-partial-perm}
  \uses{def:condition-total-1-1,def:condition-functoriality,def:flexible-condition}
  Assume a freedom of action context at a proper type index $\alpha$.

  An \emph{allowable partial permutation} is a set $\sigma$ of binary $\alpha$-conditions satisfying the following properties:
  \begin{enumerate}
  \item It is one-to-one.
  \item (Flexible litters:)  Either $\dom \sigma$ and $\rge \sigma$ both include all flexible litters, or else they both include \emph{co-$\mu$-many}, i.e.\ there are at least $\mu$-many flexible litters not in $\dom \sigma$, and dually for $\rge \sigma$.
  \item (Atoms:) For each litter $(L,A)$ not in $\dom \sigma$, then $\dom \sigma$ contains $<\kappa$-many atoms $(x,A)$ with $x \in L$; and dually for $\rge(\sigma)$.  On the other hand, for each litter $(L,A) \in \dom \sigma$ (say $\sigma_A(L)$ is the unique near-litter such that $(L,\sigma_A(L),A) \in \sigma$), then either $\dom \sigma$ contains $<\kappa$-many atoms of $(L,A)$ and $\rge \sigma$ contains $<\kappa$-many atoms of $(M,A)$, or else $\dom \sigma$ contains all atoms of $(L,A)$ and their setwise image $\sigma_A''(L)$ is precisely $\sigma_A(L)$; and dually for each litter $(L,A) \in \rge \sigma$.
  \item (Near-litters.) For each near-litter $(N,A) \in \dom \sigma$, its litter $(N^\circ,A)$ and all atoms $(x,A)$ from the symmetric difference $N \symdiff N^\circ$ are also in $A$, and $\sigma_A(N) = \sigma_A(N^\circ) \symdiff \sigma_A''(N \symdiff N^\circ)$; and dually for each near-litter in $\rge \sigma$.
  \item (Non-flexible litters.) Whenever $\sigma$ contains some triple $(f^A_{\gamma,\delta}(x),N,(-1;\delta;A))$ (where $\gamma,\delta < \beta \pathto^A \alpha$, $\delta$ is proper, and $x \in \tau_{\gamma;A}$), then $(\dom \sigma)_{\gamma;A}$ supports $x$, and every allowable permutation $\rho \in \All_A$ extending $\sigma_A$ has $N = f^A_{\gamma,\delta}(\rho_\gamma x)$.  Dually, whenever $\sigma$ contains some $(N,f^A_{\gamma,\delta}(x),(-1;\delta;A))$, then $(\rge \sigma)_{\gamma;A}$ supports $x$, and any allowable $\rho$ extending $\sigma_A$ has $N = f^A_{\gamma,\delta}(\rho^{-1}_\gamma x)$ (note the inverse in this case).
  \end{enumerate}

  We will often refer to these conditions individually, as “the allowability condition for atoms”, etc.
\end{definition}

The motivation for allowable permutations is precisely to state the freedom of action property:

\begin{definition}
  \label{def:foa-property}
  \uses{def:allowable-partial-perm,def:conditions-from-perm}
  Given a freedom of action context at a proper type index $\alpha$, say that \emph{freedom of action holds} if for every allowable permutation $\sigma$, there is some allowable permutation $\pi \in \All_\alpha$ extending $\sigma$.
\end{definition}

\begin{theorem}
  \label{thm:foa-propagates}
  \uses{def:foa-property,def:synthesise-foa-context}
  Suppose given, for each $\beta < \alpha$, a freedom of action context together with full tangle data at the top level; and such that for all their restrictions along any path $A : \gamma \to \beta$ (including identity paths), freedom of action holds.

  Then freedom of action holds in the synthesised freedom of action context at $\alpha$ (i.e.\ with the tangles and allowable permutations at $\alpha$ defined by the constructions of phase 1).
\end{theorem}

\begin{proof}
  \uses{prop:allowable-partial-perm-chain-union,lem:maximal-allowable-partial-perm-total,prop:total-allowable-partial-perm-actual}
  The proof is quite lengthy, so we break it down into various lemmas.

  In outline: We first define an ordering on allowable partial permutations (\cref{def:allowable-partial-perm-order}), show that it has unions of chains (\cref{prop:allowable-partial-perm-chain-union}), and so apply Zorn’s lemma to conclude that it has a maximal element above any element.  This is the easy part.  The main work then consists of showing that any maximal partial permutation is total and co-total (\cref{lem:maximal-allowable-partial-perm-total}), and hence is an allowable permutation (\cref{prop:total-allowable-partial-perm-actual}).

  Most lemmas involved can (and should) be given in an arbitrary freedom-of-action context, not required to be the synthesised one.
\end{proof}

\begin{definition}
  \label{def:allowable-partial-perm-order}
  \uses{def:allowable-partial-perm}
  Work in a freedom of action context at a proper type index $\alpha$.

  Given allowable partial permutations $\sigma, \rho$, say that $\sigma \sqsubseteq \rho$ (“$\sigma$ \emph{carefully extends} $\rho$”) if:

  \begin{enumerate}
  \item $\sigma \subseteq \rho$;
  \item if $\rho$ has any new flexible litter, then it has all of them (in both domain and range);
  \item within each litter, if $\dom \rho$ has any new atom, then it must have all atoms in that litter (and hence must also have the litter); and dually.
  \end{enumerate}
\end{definition}

\begin{proposition}
  \label{prop:allowable-partial-perm-chain-union}
  \uses{def:allowable-partial-perm-order}
  $\sqsubseteq$ has upper bounds for chains, given by taking unions.  That is: given a set of allowable partial permutations that is a chain under $\sqsubseteq$, its union is again an allowable partial permutation, and carefully extends each element of the chain.  (Indeed, this gives a supremum for the chain, and so shows that $\sqsubseteq$ is chain-complete; but “upper bounds” is all we need in order to apply Zorn’s lemma.)
\end{proposition}

To prove that maximal allowable partial permutations are total, we will make use of a well-ordering on (unary) conditions:

\begin{definition}
  \label{def:constrains}
  \uses{def:foa-context}
  Fix a freedom of action context at $\alpha$. Then the relation \( \prec \)  on $\Cond_\alpha$, read as \emph{“constrains”}, is defined by:
  \begin{itemize}
    \item \( (L, A) \prec (x, A) \), whenever \( L \) is a litter and \( x \in L \); (an atom is constrained by the litter it belongs to);
    \item \( (N^\circ, A) \prec (N, A) \) when \( N \) is a near-litter not equal to its corresponding litter \( N^\circ \);
    \item \( (x, A) \prec (N, A) \) for $N$ as above and all \( x \in N\,\Delta\, N^\circ \);
    \item \( (y, B:(\gamma<\beta):A) \prec (L, A) \) for all paths \( A \colon \beta \to \alpha \), and \( \gamma,\delta < \beta \), and \( L = f^A_{\gamma,\delta}(x), x \in \tau_{\gamma:A} \), and \( (y,B) \in S_x \), where \( S_x \subseteq \Cond_\gamma \) is the designated support of \( x \).
  \end{itemize}

  Note: “$x$ constrains $y$” is effectively defined separately in the three cases that $y$ is an atom, a non-litter near-litter, or a non-flexible litter. Flexible litters are not constrained by anything.

  Note: This relation is not transitive — that’s OK, it’s not intended to be!
\end{definition}

\begin{proposition}
  \label{prop:constrains-well-founded}
  \uses{def:constrains,lem:f-map-properties}
  The relation \( \prec \) is well-founded.
\end{proposition}
\begin{proof}
  By the conditions on orderings assumed in full tangle data, and the properties of $f$-maps, whenever some constraint \( (x, A) \prec (y,B) \) holds, we have \( \iota_A(x) < \iota_B(y) \) in \( \mu \).
\end{proof}

In order to make use of the inductive assumption that freedom of action holds at earlier levels, we will need a few notes about consquences of freedom of action, and about how the definitions of this section interact with restriction of the context.

\begin{proposition}
  \label{prop:restrict-allowable-partial-perm}
  \uses{def:allowable-partial-perm,def:restrict-foa-context}
  If $\sigma$ is an allowable permutation in a freedom of action context at $\alpha$, then for any $A : \beta \to \alpha$, the restriction $\sigma_A$ is again allowable in the context restricted along $A$.
\end{proposition}

\begin{proof}
  \uses{prop:total-1-1-restriction,prop:conditions-from-perm-restriction}
  Hopefully straightforward, but probably a bit lengthy, using \cref{prop:total-1-1-restriction}, \cref{prop:conditions-from-perm-restriction}.
\end{proof}

\begin{proposition}
  \label{prop:allowable-partial-perm-action}
  \uses{def:foa-property}
  Given a freedom of action context at a proper type index $\alpha$, an allowable permuation $\sigma$, and an $\alpha$-tangle $x$ such that $\dom \sigma$ supports $x$:
  \begin{enumerate}
    \item if $\pi, \pi' \in \All_\alpha$ are allowable permutations extending $\sigma$, then $\pi x = \pi' x$;
    \item if freedom of action holds, there is a unique $y \ in \tau_\alpha$ such that every allowable permutation $\pi$ extending $\sigma$ has $\pi x = y$; we denote this unique value by $\sigma x$.
  \end{enumerate}
\end{proposition}

\begin{proof}
  For the first part: given such $\pi, \pi'$, $(\pi^-1)\pi$ acts trivally on $\dom \sigma$, and hence fixes $x$.  The second part follows from the first together with the freedom of action property.
\end{proof}

\begin{lemma}
  \label{lem:maximal-allowable-partial-perm-total}
  \uses{def:allowable-partial-perm-order}
  Any allowable partial permutation that is maximal under $\sqsubseteq$ is total.
\end{lemma}

\begin{proof}
  \uses{prop:allowable-partial-perm-action,prop:constrains-well-founded,prop:restrict-allowable-partial-perm}
  This is the main hard work of the proof of \cref{thm:foa-propagates}, and should probably be broken down into separate lemmas.

  It suffices to show the claim: For any allowable partial $\sigma$, and any $x$, if everything that constrains $x$ is in $\dom \sigma$, then there is some $\sigma' \sqsupseteq \sigma$ with $x \in \dom \sigma$.  (Given this claim and a maximal element $\sigma$, it follows by induction over “constrains” that $\dom \sigma$ is all of $\Cond_\alpha$. Co-totality follows dually.)

  Proof of claim: Treat the 4 cases for $x$ separately.

  \begin{enumerate}
  \item A flexible litter $(L,A)$.  TO GIVE.
  \item An atom $(x,A)$.  TO GIVE.
  \item A non-litter near-litter $(N,A)$.  TO GIVE.
  \item A non-flexible litter $(f^A_{\gamma,\delta}(x),-1;\delta;A)$.  TO GIVE.
  \end{enumerate}

  Note: The “straightforward” parts of checking allowability are fairly repetitive between the different cases here.  This is the sort of thing that — if just tackled greedily — could take a lot of time and create a lot of code duplication.  Probably good to write a few of these cases directly, but then see if they can be abstracted out as lemmas that can be re-used across cases.  For the near-litter and non-flexible litter conditions, the point is that these are of the form “if [thing $x$] is present, then [condition $P$ holds]”, where condition $P$ is something which is clearly preserved by subset-expansion (i.e. if $\sigma \subseteq \rho$ and $P$ holds for $\sigma$, then it holds for $\rho$). So when we expand $\sigma$ to $\rho$, these allowability conditions will still hold for all things that were already in $\sigma$ — we only need to check for any new things that were added in $\rho$.

  We should also avoid code-duplication of checking dual conditions separately, probably by lemmas explicitly connecting each condition to its dual, or by explicitly making use of duals in the definition of the allowability conditions.
\end{proof}

\begin{proposition}
  \label{prop:total-allowable-partial-perm-actual}
  \uses{def:synthesise-foa-context,def:foa-property,}
  In the synthesised freedom of action context at $\alpha$, any partial allowable permutation (at $\alpha$) that is total and co-total extends to an actual allowable permutation at $\alpha$.
\end{proposition}

\begin{proof}
  \uses{prop:restrict-allowable-partial-perm,lem:coherence-unpacked}
  Take $\sigma$ a total and co-total allowable partial permutation.  For each $\beta < \alpha$, $\sigma_\beta$ is again allowable, so by the assumption of FoA at earlier levels, $\sigma_\beta$ extends to an allowable permutation $\pi_\beta \in \All_\beta$. [If we assumed $\All \to \Str$ is injective, then $\pi_\beta$ is uniquely determined, since $\sigma_\beta$ is total and co-total.]  Together these $\pi_\beta$ comprise a semi-allowable permutation $\pi$ extending $\sigma$; the allowability condition for non-flexible litters ensures that the unpacked coherence condition holds, and hence by \cref{lem:coherence-unpacked}, $\pi$ is allowable.
\end{proof}

\section{Strong supports defined}

NOTE: much of this section has not been updated since early in the formalisation, so may not match the current implementation and abstractions very closely.

Throughout this section, fix some $\alpha \in \lambda + 1$, and assume a freedom of action context at $\alpha$.

Treating supports as sets suffices for the model description, but we will need to analyze supports and orbits with more care, so it is better for purposes
of the proof to equip supports with a well-orderings.

We may write $x \leq_S y$ for $(x,y) \in S$, and $x <_S y$ when we also want to indicate that $x,y$ are distinct.

If $\pi$ is an $\alpha$-allowable permutation and $S$ is an $\alpha$-support, we define $\pi[S]$ as $$\{((\pi_A(x),A,\gamma),(\pi_B(y),B,\delta)):((x,A,\gamma),(y,B,\delta))\in S\}.$$

If $S$ is an $\alpha$-support, we define $S^+$ as $\{(x,A,\alpha):(x,A,\alpha) \in S\}$.

We can then say that $S$ is a support of $X$ if $X$ is an $\alpha$-code, $S$ is an $\alpha$-support, and for any $\alpha$-allowable permutation $\pi$, if $\pi[S^+]=S^+$ then $\pi(x)=x$.  In some sense the items in the support with third components less than $\alpha$ are fluff, but they {\em are\/} important as we will see.

\begin{description}
\item[Remark on definitions of support and symmetry:]  It should be clear that the supports we have defined here do exactly the same work as the set supports in the model description (since the additional order structure and the third components of support domain elements actually do no work at this point).
\end{description}

% \begin{comment}
This probably represents a chunk of formal verification work, as what is obvious to people is not always obvious to theorem provers.
% \end{comment}

\begin{definition}
  \label{def:strong-support}
  \uses{def:foa-context,def:constrains}
  A \emph{strong support} is a support $S$ equipped with a well-ordering $\prec_S$, such that whenever $c \in S$ and $d$ constrains $c$, then $d \in S$ and $d \prec_S c$.
\end{definition}

\begin{lemma}
  \label{lem:strengthen-support}
  \uses{def:strong-support}
  Any support is a subset of some strong support (and hence any tangle is supported by some strong support).
\end{lemma}

\begin{proof}
  \uses{prop:constrains-well-founded}
  Given a support $S$, take its down-closure of $\downarrow S$ under the “constrains” relation.

  First we need to check this has size $<\kappa$.  The “constrains” relation is well-founded, and each condition has $<\kappa$ (immediate) predecessors, so by induction, the down-closure of any singleton is of size $<kappa$. Then $ \downarrow S$ is the union of the down-closures of its singletons (down-closure under any relation preserves arbitrary unions); so it’s a union of $<\kappa$-many sets of size $<\kappa$.

  Now “constrains” on $\downarrow S$ is a well-founded relation; and any well-founded relation can be extended to a well-ordering.  [This is a standard general theorem which is hopefully already in mathlib. If not, it can be proven probably most easily by Zorn’s lemma.]
\end{proof}

\section{Types are of size \texorpdfstring{$\mu$}{μ} (so the construction actually succeeds)}

[Note: this section is treated MUCH more clearly in Randall’s more recent versions of the note — we should certainly pull in from that newer version before attempting to formalise the section.]

Now we argue that (given that everything worked out correctly already at lower types) each type $\alpha$ is of size $\mu$, which ensures
that the construction actually succeeds at every type.

\begin{definition}
\label {def:coding-function}
\uses{def:foa-context}
For any support $S$ and tangle $x$, we can define a function $\chi_{x,S}$ which sends $T=\pi(S)$ to $\pi(x)$ for every $T$ in the orbit of $S$ under
the action of allowable permutations.  We call such functions {\em coding functions\/}.  Note that if $\pi[S]=\pi'[S]$ then $(\pi^{-1}\circ \pi')[S]= S$, so
$(\pi^{-1}\circ \pi')(x)= x$, so $\pi(x)=\pi'(x)$, ensuring that the map $\chi_{x,S}$ for which we gave an implicit definition is well defined.
\end{definition}

The strategy of our argument for the size of the types is to show that that there are $<\mu$ coding functions for each type whose domain includes a strong support, which implies that there are no more than $\mu$ (and so exactly $\mu$) elements of each type, since every element of a type is obtainable by applying a coding function (of which there are $<\mu$) to a support (of which there are $\mu$), and every element of a type has a strong support.

We describe all coding functions for type 0 (without concerning ourselves about whether supports are strong).  The orbit of a 0-support in the allowable permutations is determined by the positions in the support order occupied by near-litters, and for each position in the support order occupied by a singleton, the position, if any, of the near-litter in the support order which includes it.  There are no more than $2^\kappa$ ways to specify an orbit.  Now for each such equivalence class, there is a natural partition of type $-1$ into near-litters, singletons, and a large complement set.  Notice that near-litters in the partition will be obtained by removing any singletons in the domain of the support which are included in them.  The partition has $\nu<\kappa$ elements, and there will be $2^\nu\leq 2^\kappa$ coding functions for that orbit in the supports, determined by specifying for each compartment in the partition whether it is to be included or excluded from the set computed from a support in that orbit.  So there are no more than $2^\kappa<\mu$ coding functions over type 0.

We specify an object $X$ and a strong support $S$ for $X$, and develop a recipe for the coding function $\chi_{X,S}$ which can be used to see that there are $<\mu$ coding functions.

$X = (\alpha,\beta,B)$, where $B$ is a subset of $\tau_\beta$.  By inductive hypothesis, each element $b$ of $B$ can be expressed as $\chi_{b,T_b}(T_b)$, where $T_b$ is a strong support for $b$ end extending $S_\beta$ (which is defined as the largest $\beta$-support $U$ such that $U^{\{\alpha\}} \subseteq S$).

We claim that $\chi_{X,S}$ can be defined in terms of the orbit of $S$ in the allowable permutations and the set of coding functions $\chi_{b,T_b}$.  There are $<\mu$ sets of type $\beta$ coding functions by inductive hypothesis, and we will argue that there are $<\mu$ orbits in the $\alpha$-strong supports under allowable permutations, so this will imply that there are $\leq \mu$ elements of type $\alpha$ (it is obvious that there are $\geq \mu$ elements of each type).
Of course we get $\leq \mu$ codes for each $\beta<\alpha$, but we know that $\lambda<\kappa<\mu$.

The definition that we claim works is that $\chi_{X,S}(U) = (\alpha,\beta,B')$, where $B'$ is the set of all $\chi_{b,T_b}(U')$ for $b \in B$ and $U'$ end extending $U_\beta$.  Clearly this definition depends only on the orbit of $S$ and the set of coding functions derived from $B$.

The function we have defined is certainly a coding function, in the sense that $\chi_{X,S}(\pi(S)) = \pi(\chi_{X,S}(S))$.  What requires work is to show that
$\chi_{X,S}(S)=S$, from which it follows that it is in fact the intended function.

Clearly each $b \in B$ belongs to $\chi_{X,S}(S)$ as defined, because $b = \chi_{b,T_b}(T_b)$, and $T_b$ end extends $S_\beta$.

An arbitrary $c \in \chi_{X,S}(S)$ is of the form $\chi_{b,T_b}(U)$, where $U$ end extends $S_\beta$ and of course must be in the orbit of $T_b$ under allowable permutations.

Our strategy is to show that there is an allowable permutation $\pi$ which fixes $X$ (so that $\pi_\beta``B = B$) such that $\pi_\beta[T_b]=U$, so that
$\pi_\beta(b) = c$, so $c \in B$, whence $\chi_{X,S}(S)$ as defined is equal to $X$ as required.

We build a support $S+T_b^{\{\alpha\}}$ and a support $S+U^{\{\alpha\}}$ with parallel structure by appending $T_b$ (respectively $U$) to $S$ then removing all but the first occurrence of each repeated item.  The parallelism of structure is enforced by the identity of items taken from $S \setminus S_\beta$
in both supports and the fact that $U$ is the image of $T_b$ under some allowable permutation.

We construct an $\alpha$-allowable permutation whose action takes one of these supports to the other, which will complete the plan given above.
For this we use the freedom of action theorem.  We define a local bijection which sends $(A,x)$ to $y$ just in case a $(\beta,A,\{x\})$ in the first support corresponds to a $(\beta,A,\{y\})$ in the other, and further enforces agreement of derivatives  of the permutation to be constructed with derivatives of the known permutation $\pi'$ sending $T_b$ to $U$ at exceptions of derivatives of $\pi'$ which lie in litters in $T_b$.  This causes singleton items in the first support to be mapped to the corresponding singleton items in the other support.  We have to argue that litters in the domain of $S+T_b^{\{\alpha\}}$ (which is a strong support) are mapped to the correct near-litters in the domain of $S+U^{\{\alpha\}}$.  If there is a failure, there is a first one.  The local cardinal of the first failure is treated correctly (because a support of it is treated correctly), so the failure must consist in the map constructed having an exception which is moved by the permutation into or out of the litter in question (if a litter $L$ in $T_b$ is mapped to a near-litter $N$ in $U$, all elements of $N \symdiff N^\circ$ are treated correctly because they are values at exceptions of the known permutation), so a failure implies an exception of the constructed permutation lying in $L$ which is not an exception of the known map and whose singleton is not an item in $T_b$, and there are no such exceptions.

The constructed map fixes $X$ because of its identity action on $S$, and it sends $b$ to $c$ because its action sends $T_b$ to $U$, which is what we claimed,

The final move is to argue that there are $<\mu$ orbits in the $\alpha$-allowable permutations.  The idea is that the orbit in which a permutation lies
is completely determined by a certain amount of combinatorial information, similarly to what happened in type 0 but a bit more complex.  The orbit is specified if we know the second and third components of each item, taken from $\lambda$ items in each case, the first and second components of the first item, and whether the third component is a singleton or a near-litter.  If this is a singleton, we want to know the position in the support of a near-litter containing it (which will be present).  If this is a near-litter and its local cardinal is an image under an $f$ map, we can extract from information about the preceding part of the support order a subsupport which is an index-raised version of a strong support for the near-litter and so for its inverse image under the $f$ map:  as part of our specification, we take the coding function which generates that inverse image.

We give exact details.  If $S$ is a strong support (or an image of a strong support under an allowable permutation), we define
its specification $S^*$ as a well-ordering of the same length in which an item $((\beta,-1,x),A,\gamma)$ will be replaced by an item
$((\beta,-1,X),A,\gamma)$ in a way that we describe.  If $x=\{y\}$, we replace $x$ with $\{\delta\}$, where $\delta$ is the position of a typed near-litter containing $y$ in the obvious sense.  If $x$ is a near litter which does not belong to any $f_{\gamma,\beta}(y)$ with $\gamma<{\tt min}(A)$, then
$X= \emptyset$.  If $x \in f_{\gamma,\beta}(y)$ with $\gamma<{\tt min}(A)$, then we extract the maximal strong support $T$ of $y$ such that
$T^{\{\alpha\}} \subseteq S$, and set $X = \chi_{y,T}$, a coding function.

There is a straightforward argument by induction on the structure of strong supports that if we have two items with strong supports which have the same specification in the sense we have just described, there is an allowable permutation (by freedom of action) whose action sends the one support to the other, and so the one item to the other.

Suppose $S^* = T^*$:  we discuss the construction of an allowable permutation $\pi$ such that $\pi[S^*]=T^*$.  It should not be a surprise
that we construct the desired $\pi$ as an extension (as in the freedom of action theorem) of a local bijection defined by consulting the parallel structures of $S$ and $T$.  If $((\beta,-1,\{x\}),A,\delta)$ and $((\beta,-1,\{y\}),A,\delta)$ appear at corresponding positions in $S$ and $T$, we have $\pi^0$ send
$(A,x)$ to $y$.  If $((\beta,-1,M),A,\delta)$ and $((\beta,-1,N),A,\delta)$ appear at corresponding positions in $S$ and $T$ and $((\beta,-1,\emptyset),A,\delta)$ appears at the corresponding position in $S^*=T^*$, we can provide that the map $\chi_A$ used in the freedom of action construction
maps $[M]$ to $[N]$.  If $((\beta,-1,M),A,\delta)$ and $((\beta,-1,N),A,\delta)$ appear at corresponding positions in $S$ and $T$ and $((\beta,-1,\emptyset),\chi_{y,T},\delta)$ appears at the corresponding position in $S^*=T^*$,  then we know by the inductive hypothesis that everything works before this item in the support that the action of the permutation $\pi_A$ constructed so far will send $[M]$ to $[N]$.  In both near-litter cases, we need to do a little more work to ensure that $M$ is mapped exactly to $N$ without exceptions.  The idea is to extend $\pi^0_A$ so as to map each element of
$M$ which is not in $M^\circ$ to something in $N^\circ \cap N$, and each element of $M^\circ$ which is not in $M$ to something not in $N$, and do the analogous things for $(\pi^0_A)^{-1}$, and then fill in orbits, which only requires countably many atoms for each orbit [this is why we take $\kappa$ to be uncountable], with the rule that images and preimages chosen in the filling out process are chosen so as not to create exceptions (their images and preimages will agree with expected actions on near-litters in the supports, which is really action on their local cardinals, because all elements of the symmetric differences of near-litters with their corresponding litters are treated individually).  The extension of this local bijection will have exactly the desired effect.

There are clearly $<\mu$ specifications since these are small structures built with components taken from sets of size $<\mu$.  Notice the recursive dependency on the coding functions for items of lower types being taken from sets of size $<\mu$.

Pulling out the main items from the discussion above, for formalisation targets:

\begin{definition}
  \label{def:support-spec}
  \uses{def:foa-context}
  Fix a freedom of action context for $\alpha$.  A \emph{support-specification} is \ldots [this is quite long to define; we should get the text from more recent versions of Randall’s note]
\end{definition}

\begin{lemma}
  \label{lem:count-support-specs}
  \uses{def:support-spec}
  There are $<\mu$-many support specifications.
\end{lemma}

\begin{definition}
  \label{def:support-spec-realisation}
  \uses{def:support-spec,def:strong-support}
  Any support specification can be realised (non-uniquely) to give a strong support.
\end{definition}

\begin{lemma}
  \label{lem:support-spec-realisation-unique}
  \uses{def:support-spec-realisation,def:freedom-of-action-statement-old}
  If freedom of action holds at $\alpha$, then realisations of a support specification are unique modulo the group action.  That is, for any two realisations $S, S'$ of a support specification $S$, there is some allowable permutation $\pi$ such that $\pi S = S'$.
\end{lemma}

\begin{proof}
  Hopefully quite direct, given heavy use of freedom of action.  May need some lemmas about realisations.
\end{proof}

\begin{lemma}
  \label{lem:strong-support-has-spec}
  \uses{def:support-spec-realisation}
  Every strong support can be obtained as the realisation of some specification
\end{lemma}

\begin{corollary}
  \label{cor:count-strong-supports}
  \uses{def:strong-support}
  There are $<\mu$-many orbits of strong supports, under the group action of allowable permutations.
\end{corollary}

\begin{proof}
  \uses{lem:strong-support-has-spec,lem:count-support-specs}
  Immediate from \cref{lem:count-support-specs} and \cref{lem:strong-support-has-spec}.
\end{proof}

Now, everything that we did with supports, we repeat with coding functions.

\begin{definition}
  \label{def:coding-function-spec}
  \uses{def:support-spec,def:coding-function}
  A \emph{coding function specification} is \ldots [again, see recent versions of Randall’s note]
\end{definition}

\begin{lemma}
  \label{lem:count-coding-function-specs}
  \uses{def:coding-function-spec}
  There are $<\mu$-many coding function specifications.
\end{lemma}

\begin{definition}
  \label{def:coding-function-spec-realisation}
  \uses{def:coding-function-spec,def:support-spec-realisation}
  Any coding function specification can be realised as a coding function.
\end{definition}

\begin{lemma}
  \label{lem:coding-function-has-spec}
  \uses{def:coding-function-spec-realisation}
  Every coding function can be obtained as the realisation of some specification
\end{lemma}

\begin{proof}
  \uses{lem:strong-support-has-spec}
  See Randall’s more recent versions of the note.
\end{proof}

\begin{corollary}
  \label{cor:count-coding-functions}
  \uses{def:coding-function}
  There are $<\mu$-many coding functions.
\end{corollary}

\begin{proof}
  \uses{lem:coding-function-has-spec,lem:count-coding-function-specs}
  Immediate from \cref{lem:count-coding-function-specs} and \cref{lem:coding-function-has-spec}.
\end{proof}

\begin{corollary}
  \label{cor:count-tangles}
  \uses{def:foa-property}
  There are $\mu$-many $\alpha$-tangles.
\end{corollary}

\begin{proof}
  \uses{lem:strengthen-support,lem:count-supports,cor:count-coding-functions}
  Every tangle can be obtained as a coding function (of which there are $<\mu$) applied to a strong support (of which there are $\mu$).
\end{proof}

This completes the proof that each type is of size $\mu$, which finally closes the loop on the recursion --- or very nearly so: we still have to show that the orderings can be chosen to satisfy the extra technical conditions required.

\begin{lemma}
  \label{lem:position-functions-propagate}
  \uses{def:foa-property}
  Given a freedom of action context for $\alpha$ satisfying freedom of action at $\alpha$, we can choose supports $S(x)$ for all $\alpha$-tangles $x$ and a position function $\iota_\alpha : \tau_\alpha \to \mu$ satisfying the conditions demanded in \cref{def:tangle-data}:
  \begin{enumerate}
    \item for each litter $L$, the typed litter of $L$ precedes the typed singletons of all its elements $a \in L$ --- explicitly, $\iota(j(L)) < \iota(k(a))$;
    \item for each near-litter $N$ which is not a litter, $j(N)$ comes after its (typed) litter $j(N^\circ)$, and after (the typed singletons of) all elements of $N \symdiff N^\circ$;

    \item for each $x$ in $\tau_\alpha$ that is not a typed litter or singleton, $x$ comes later than all of its designated support -- explicitly, for each $(a,A)$ or $(N,A)$ in the in $S(x)$, we must have $\iota_\alpha(j(N)), \iota_\alpha(k(a))<\iota_\alpha(x)$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  \uses{cor:count-tangles}
  The constraints can be seen as defining a relation $\prec$ on $\tau_\alpha$; we want to extend $\prec$ to a well-ordering of order-type $\leq \mu$, or equivalently, to give an injection $\iota:\tau_\alpha \to \mu$ sending $\prec$ to $<$.  We know:
  \begin{itemize}
  \item $\prec$ has depth 4: it is of the form “litters $\prec$ atoms $\prec$ other near-litters $\prec$ everything else”;
  \item each tangle has $<\kappa$-many predecessors under $\prec$;
  \item $|\tau_\mu| \leq \mu$.
  \end{itemize}
  These conditions should suffice to imply the existence of the desired ordering/functions.
\end{proof}

% \begin{comment}
{\bf Note for the formal verification project:}  I think everything is here, but filling in details to the satisfaction of a theorem prover will be work.
% \end{comment}

\section{Completing the recursion}

We can now wrap up the recursion.

\begin{definition}
  \label{def:main-recursion}
  \uses{thm:foa-propagates,lem:position-functions-propagate}
  For each $\alpha \in \lambda$, we have the following data:
  \begin{enumerate}
  \item a full freedom of action context $C_\alpha$ (whose components we write as $\All^\alpha_A$, $\tau^\alpha_A$, etc.),
  \item such that each restruction $(C_\alpha)_A$ satisfies freedom of action,
  \item and with $<\mu$-many coding functions at the top level.
  \end{enumerate}

  This data is defined by recursion on $\alpha$.  Given such data for each $\beta < \alpha$,
  \begin{enumerate}
  \item the core freedom of action context at $\alpha$ is synthesised by \cref{def:synthesise-foa-context} (i.e.\ using the constructions of phase 1 to give the core tangle data at the top level, and assembling the context at proper paths from the given lower contexts);
  \item freedom of action at the top level follows by \cref{thm:foa-propagates};
  \item the top-level coding functions are bounded by \cref{cor:count-coding-functions};
  \item this allows us to complete the full tangle data at the top level, by \cref{lem:position-functions-propagate}.
  \end{enumerate}
\end{definition}

\newcommand{\Tangle}{\mathrm{Tangle}}
\begin{definition}
  \label{def:tangle-completed}
  \uses{def:main-recursion}
  The (actual, genuine, definitive!) tangles are the structure $\Tangle$ extracted from the freedom of action contexts defined in \cref{def:main-recursion} as follows:
  \begin{enumerate}
    \item $\tau_\alpha$ is the top-level tangles of the freedom of action context at $\alpha$;
    \item “by construction” (i.e. by the defining clause of \cref{def:main-recursion}), $\tau_\alpha$ is constructed by \cref{def:tangle} from the tangles $\tau_\beta$ for $\beta < \alpha$; thus \cref{def:ttt-membership} gives a membership relation $\in_{\beta,\alpha}$ from $\tau_\beta$ to $\tau_\alpha$, for each $\beta < \alpha$.
  \end{enumerate}

  [Note: The definition of $\in_{\beta,\alpha}$ uses a type equality on $\tau_\alpha$, so may not be very nice to work with directly in subsequenet lemmas.  However, it’s hard to see how any approach to this inductively constructed structure could avoid such issues.  When we get to this stage, we can think about how to deal with this issue.]
\end{definition}

\newpage

\chapter{Tangles model tangled type theory}

Now we can prove that the structure constructed in the previous chapters is a model of tangled type theory.

\section{The structure is a model of predicative TTT}

There is then a very direct proof that the structure presented is a model of predicative TTT (in which the definition of a set at a particular type may not mention any higher type).  Use $E$ for the membership relation of the structure.  It should be evident that $x E y \leftrightarrow \pi_\beta(x) E \pi(y)$,
where $x$ is of type $\beta$, $y$ is of type $\alpha$, and $\pi$ is an $\alpha$-allowable permutation.

Suppose that we are considering the existence of $\{x : \phi^s\}$, where $\phi$ is a formula of the language of TST with $\in$ translated as $E$, and $s$ is a strictly increasing sequence of types.  The truth value of each subformula of $\phi$ will be preserved if we replace each $x$ of type $s(i)$ with $\pi_{A_{s,i}}(x)$, where
$x=s(j)$ and $A_{s,i}$ is the set of all $s_k$ for $i \leq k \leq j+1$.  The formula $\phi$ will contain various parameters $a_i$ of types $s(n_i)$ and it is then evident that the set $\{x : \phi^s\}$ will be fixed by any $s(j+1)$-allowable permutation $\pi$ such that $\pi_{A{s,n_i}}$ fixes $a_i$ for each $i$.  But this means that
$(s(j+1),s(j),\{x : \phi^s\})$ is symmetric and belongs to type $s(j+1)$.

This procedure will certainly work if the set definition is predicative (all bound variables are of type no higher than that of $x$, parameters at the type
of the set being defined are allowed).

There are easier proofs of the consistency of predicative tangled type theory;  there is a reason of course that we have pursued this one.
% \begin{comment}
{\bf Note for the formal verification project:}  We note that in order to avoid metamathematics, we actually suggest proving finitely many instances of comprehension with typed parameters from which the full comprehension scheme can be deduced.  That there are such finite schemes (mod the infinite sequence of types) is well-known.
% \end{comment}

\newpage
\section{Impredicativity:  verifying the axiom of union}

What remains to complete the proof is that typed versions of the axiom of set union hold.  That this is sufficient is a fact about predicative type theory.
If we have predicative comprehension and union, we note that for any formula $\phi$, $\{\iota^k(x):\phi(x)\}$ will be predicative if $k$ is taken to be large enough, then application of union $k$ times to this set will give $\{x:\phi(x)\}$.  $\iota(x)$ here denotes $\{x\}$.  It is evidently sufficient to prove that unions of sets of singletons exist.

So what we need to show is that if $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ is symmetric, then $(\beta,\gamma,G)$ is symmetric.

Suppose that $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ is symmetric.  It then has a strong support $S$.  We claim that $S_\beta$ (same notion defined above) is a $\beta$-support for $(\beta,\gamma,G)$.

Suppose that $\pi[S_\beta]=S_\beta$.

Any $g \in G$ has a strong $\gamma$-support $T$ which extends $(S_\beta)_\gamma$.

Construct using freedom of action technology a permutation $\pi^*$ which acts as the identity on $S \setminus S_\beta$, such that $\pi^*_\beta$ agrees with $\pi$ on $S_\beta$ [so in fact $\pi^*$ will fix $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$) and $(\pi^*_\beta)_\gamma$ agrees with $\pi_\gamma$ on $T$, both on the orbits under $\pi$ of items in $T$ and on the orbits under $\pi$ of exceptions of $\pi$ which are in litters in $T$.  It will follow that $\pi^*$ fixes $(\alpha,\beta,\{(\beta,\gamma,\{g\}):g \in G\})$ and that $(\pi^*_\beta)_\gamma$ has the same value as $\pi_\gamma$ at $g$, which means that $\pi_\gamma(g) \in G$ (and the same things follow for the inverse of $\pi$) which verifies that that $S_\beta$ (same notion defined above) is a $\beta$-support for $(\beta,\gamma,G)$, so the axiom of union holds in the interpreted TTT.

The application of the freedom of action theorem works because no movement of typed atoms of type $\gamma$ stipulated by the behaviour of $\pi_\gamma$ can force
movement of elements of $S \setminus S_\beta$, because this would have to be mediated by the action of $\pi$ on $S_\beta$, which fixes all elements of $S_\beta$.
% \begin{comment}
{\bf Note for formal verification project:}  This is a high level description which will probably acquire more detailed text if we get to it.  The whole idea is here, I'm not saying there is a gap.  But I have a strong suspicion that unwinding the details will induce more text.
% \end{comment}

% preamble  \end{document}
