\section{Strong supports}
\begin{definition}
  \uses{def:StrSupport}
  \label{def:StrSupport.Occurs}
  \lean{ConNF.instPreorderSupport}
  \leanok
  We define a preorder \( \preceq \) on base supports by \( S \preceq T \) if and only if \( \im S^\Atom \subseteq \im T^\Atom \) and \( \im S^\NearLitter \subseteq \im T^\NearLitter \).
  For \( \beta \)-supports, we define \( S \preceq T \) if and only if \( S_A \preceq T_A \) for each \( A \).
\end{definition}
\begin{definition}
  \uses{def:StrSupport,def:InflexiblePath,def:Interference}
  \label{def:Strong}
  \lean{ConNF.Support.Strong}
  \leanok
  A \( \beta \)-support \( S \) is \emph{strong} if:
  \begin{itemize}
    \item for every pair of near-litters \( N_1, N_2 \in \im S_A^\NearLitter \), we have \( \interf(N_1, N_2) \subseteq \im S_A^\Atom \); and
    \item for every inflexible path \( I = (\gamma,\delta,\varepsilon,A) \) and \( t : \Tang_\delta \), if there is a near-litter \( N \in \im S_{{A_\varepsilon}_\bot}^\NearLitter \) with \( N^\circ = f_{\delta,\varepsilon}(t) \), then \( \supp(t) \preceq S_{A_\delta} \).
  \end{itemize}
\end{definition}
\begin{proposition}
  \uses{def:Strong}
  \label{prop:Strong.smul}
  \lean{ConNF.Support.Strong.smul}
  \leanok
  If \( S \) is a strong \( \beta \)-support and \( \rho \) is \( \beta \)-allowable, then \( \rho(S) \) is strong.
\end{proposition}
\begin{proof}
  \leanok
  Interference is stable under application of allowable permutations, and the required supports are also preserved under action of allowable permutations.
\end{proof}
\begin{proposition}
  \uses{def:Strong}
  \label{prop:exists_strong}
  \lean{ConNF.Support.strong_strong}
  \leanok
  For every support \( S \), there is a strong support \( T \succeq S \).
\end{proposition}
\begin{proof}
  \leanok
  We define a relation \( R \) on pairs \( (A, N) \) where \( A : \beta \tpath \bot \) and \( N \) is a near-litter by the following constructor.
  If \( I = (\gamma,\delta,\varepsilon,A) \) and \( t : \Tang_\delta \), then for any near-litter \( N_1 \) such that \( N_1^\circ = f_{\delta,\varepsilon}(t) \) and any path \( B : \delta \tpath \bot \) and near-litter \( N_2 \in \supp(t)_B^\NearLitter \), we define \( ((A_\delta)_B, N_2) \mathrel{R} ((A_\varepsilon)_\bot, N_1) \).
  This is well-founded, because if \( (B, N_2) \mathrel{R} (A, N_1) \) then \( \iota(N_2) < \iota(N_1) \).
  For any small set \( s \) of such pairs, the transitive closure of \( s \) under \( R \) is small.

  Let \( S \) be a support, and let \( s \) be the transitive closure of the set of pairs \( (A, N) \) such that \( N \in \im S_A^\NearLitter \).
  Generate a support \( T \) from \( S \) and \( s \) using the fact that every small set is the range of some enumeration.
  This satisfies the second condition of being a strong support.

  Now, for any base support \( T \), we define its \emph{interference support} to be a base support \( U \) consisting of just the atoms in the interference of all near-litters that appear in \( T \).
  We may extend this definition to structural supports.

  Finally, if \( U \) is the interference support of the \( T \) defined above, the support \( T + U \) is strong, and since \( S \succeq T \), we conclude \( S \preceq T + U \).
\end{proof}

\section{Coding functions}
\begin{definition}
  \uses{def:StrSupport,def:ModelData}
  \label{def:SupportOrbit}
  For a type index \( \beta \leq \alpha \), a \emph{\( \beta \)-support orbit} is the quotient of \( \StrSupp_\beta \) under the relation of being in the same orbit under \( \beta \)-allowable permutations.\footnote{This can be implemented using \texttt{MulAction.orbitRel.Quotient}. We need to make sure there's plenty of API for support orbits to avoid code duplication.}
\end{definition}
\begin{definition}
  \uses{def:SupportOrbit}
  \label{def:CodingFunction}
  For any type index \( \beta \leq \alpha \), a \emph{\( \beta \)-coding function} is a relation \( \chi : \StrSupp_\beta \to \TSet_\beta \to \Prop \) such that:
  \begin{itemize}
    \item \( \chi \) is coinjective;
    \item \( \chi \) is nonempty;
    \item if \( (S, x) \in \chi \), then \( S \) is a support for \( x \);
    \item if \( S, T \in \coim \chi \) then \( S \) and \( T \) are in the same support orbit;
    \item if \( (S, x) \in \chi \) and \( \rho \) is \( \beta \)-allowable, then \( (\rho(S), \rho(x)) \in \chi \).
  \end{itemize}
\end{definition}
\begin{proposition}[extensionality for coding functions]
  \uses{def:CodingFunction}
  \label{prop:CodingFunction.ext}
  Let \( \chi_1, \chi_2 \) be \( \beta \)-coding functions.
  If \( (S, x) \in \chi_1, \chi_2 \), then \( \chi_1 = \chi_2 \).
\end{proposition}
\begin{proof}
  We show \( \chi_1 \subseteq \chi_2 \); the result then follows by antisymmetry.
  Suppose \( (T, y) \in \chi_1 \).
  Then \( T = \rho(S) \) for some \( \beta \)-allowable \( \rho \).
  As \( (\rho(S), \rho(x)) \in \chi_1 \) and \( \chi_1 \) is coinjective, we obtain \( y = \rho(x) \).
  Hence \( (T, y) \in \chi_2 \) as required.
\end{proof}
\begin{definition}
  \uses{def:CodingFunction}
  \label{def:code}
  Let \( t : \Tang_\beta \).
  Then we define the coding function \( \chi_t \) by the constructor
  \[ \forall \rho : \AllPerm_\beta,\, (\rho(\supp(t)), \rho(\set(t))) \in \chi \]
  This is clearly a coding function, and satisfies \( (\supp(t), \set(t)) \in \chi_t \).
\end{definition}
\begin{proposition}
  \uses{def:CodingFunction}
  \label{def:code_eq_code_iff}
  Let \( t, u : \Tang_\beta \).
  Then \( \chi_t = \chi_u \) if and only if there is a \( \beta \)-allowable \( \rho \) with \( \rho(t) = u \).
\end{proposition}
\begin{proof}
  \uses{prop:CodingFunction.ext}
  If \( \rho(t) = u \), then \( (\supp(t), \set(t)) \in \chi_t \) implies \( (\supp(u), \set(u)) \in \chi_t \), giving \( \chi_t = \chi_u \) by \cref{prop:CodingFunction.ext}.
  Conversely if \( \chi_t = \chi_u \), then \( (\supp(u), \set(u)) \in \chi_t \), so there is \( \rho \) such that \( \rho(\supp(t)) = \supp(u) \), and \( (\rho(\supp(t)), \rho(\set(t))) \in \chi_t \), so by coinjectivity we obtain \( \rho(set(t)) = \set(u) \) as required.
\end{proof}

\section{Specifications}
\begin{definition}
  \uses{def:CodingFunction}
  \label{def:Spec}
  An \emph{atom condition} is a pair \( (s, t) \) where \( s, t : \Set \kappa \).
  A \emph{\( \beta \)-near-litter condition} is either
  \begin{itemize}
    \item a \emph{flexible condition}, consisting of a set \( s : \Set \kappa \); or
    \item an \emph{inflexible condition}, consisting of an inflexible \( \beta \)-path \( I = (\gamma,\delta,\varepsilon,A) \), a \( \delta \)-coding function \( \chi \), and two \( \delta \)-trees \( R^\Atom, R^\NearLitter \) of relations on \( \kappa \).
  \end{itemize}
  A \emph{\( \beta \)-specification} is a pair \( (\sigma^\Atom, \sigma^\NearLitter) \) where
  \begin{itemize}
    \item \( \sigma^\Atom \) is a \( \beta \)-tree of enumerations of atom conditions; and
    \item \( \sigma^\NearLitter \) is a \( \beta \)-tree of enumerations of \( \beta \)-near-litter conditions.
  \end{itemize}
\end{definition}
\begin{definition}
  \uses{def:Spec,def:InflexiblePath,def:code}
  \label{def:StrSupport.spec}
  Let \( S \) be a \( \beta \)-support.
  Then \emph{its specification} is the \( \beta \)-specification \( \sigma = \spec(S) \) given by the following constructors.
  \begin{itemize}
    \item Whenever \( (i, a) \in S_A^\Atom \), we have \( (i, (s, t)) \in \sigma_A^\Atom \) where
    \[ s = \{ j : \kappa \mid (j, a) \in S_A^\Atom \};\quad t = \{ j : \kappa \mid \exists N,\, (j, N) \in S_A^\NearLitter \wedge a \in N \} \]
    \item Whenever \( (i, N) \in S_A^\NearLitter \) and \( N^\circ \) is \( A \)-flexible, we have \( (i, c) \in \sigma_A^\NearLitter \) where \( c \) is the flexible condition given by
    \[ s = \{ j : \kappa \mid \exists N',\, (j, N') \in S_A^\NearLitter \wedge N^\circ = {N'}^\circ \} \]
    \item Whenever \( I = (\gamma,\delta,\varepsilon,A) \) is an inflexible \( \beta \)-path, \( t : \Tang_\delta \), and \( (i, N) \in S_{{A_\varepsilon}_\bot}^\NearLitter \) is such that \( N^\circ = f_{\delta,\varepsilon}(t) \), we have \( (i, c) \in \sigma_{{A_\varepsilon}_\bot}^\NearLitter \) where \( c \) is the inflexible condition given by path \( I \) and coding function \( \chi_t \), and \( R^\Atom \) and \( R^\NearLitter \) are the \( \delta \)-trees of relations given by the constructors
    \begin{align*}
      &\forall i,\, \forall j,\, \forall a,\, (i, a) \in S_{{A_\delta}_B}^\Atom \to (j, a) \in \supp(t)_B^\Atom \to (i, j) \in R_B^\Atom \\
      &\forall i,\, \forall j,\, \forall N,\, (i, N) \in S_{{A_\delta}_B}^\NearLitter \to (j, N) \in \supp(t)_B^\NearLitter \to (i, j) \in R_B^\NearLitter
    \end{align*}
  \end{itemize}
\end{definition}
\begin{proposition}
  \uses{def:StrSupport.spec,def:code_eq_code_iff}
  \label{prop:spec_eq_spec_iff}
  Let \( S, T \) be \( \beta \)-supports.
  Then \( \spec(S) = \spec(T) \) if and only if\footnote{The following bullet points should comprise a proposition type relating \( S \) and \( T \).}
  \begin{itemize}
    \item \( \coim S_A^\Atom = \coim T_A^\Atom \) and \( \coim S_A^\NearLitter = \coim T_A^\NearLitter \).
    \item (atom condition) Whenever \( (i, a_1) \in S_A^\Atom \) and \( (i, a_2) \in T_A^\Atom \), we have
    \[ \forall j,\, (j, a_1) \in S_A^\Atom \leftrightarrow (j, a_2) \in T_A^\Atom \]
    and
    \[ \forall j,\, (\exists N,\, (j, N) \in S_A^\NearLitter \wedge a_1 \in N) \leftrightarrow (\exists N,\, (j, N) \in T_A^\NearLitter \wedge a_2 \in N) \]
    \item (flexible condition) Whenever \( (i, N_1) \in S_A^\NearLitter \) and \( (i, N_2) \in T_A^\NearLitter \), if \( N_1^\circ \) is \( A \)-flexible, then so is \( N_2^\circ \), and
    \[ \forall j,\, (\exists N',\, (j, N') \in S_A^\NearLitter \wedge N_1^\circ = {N'}^\circ) \leftrightarrow (\exists N',\, (j, N') \in T_A^\NearLitter \wedge N_2^\circ = {N'}^\circ) \]
    \item (inflexible condition) Let \( I = (\gamma,\delta,\varepsilon) \) be an inflexible \( \beta \)-path and let \( t : \Tang_\delta \).
    Then whenever \( (i, N_1) \in S_{{A_\varepsilon}_\bot}^\NearLitter \) and \( (i, N_2) \in T_{{A_\varepsilon}_\bot}^\NearLitter \) are such that \( N_1^\circ = f_{\delta,\varepsilon}(t) \), there is some \( \delta \)-allowable permutation \( \rho \) such that \( N_2^\circ = f_{\delta,\varepsilon}(\rho(t)) \), and
    \begin{align*}
      \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom &\to \forall i,\, (i, a) \in S_{{A_\delta}_B}^\Atom \leftrightarrow (i, \rho_B(a)) \in T_{{A_\delta}_B}^\Atom \\
      \forall j,\, \forall N,\, (j, N) \in \supp(t)_B^\NearLitter &\to \forall i,\, (i, N) \in S_{{A_\delta}_B}^\NearLitter \leftrightarrow (i, \rho_B(N)) \in T_{{A_\delta}_B}^\NearLitter
    \end{align*}
  \end{itemize}
\end{proposition}
\begin{proof}
  % TODO: Flesh this out?
  We will only sketch the fourth bullet point of this proof; the remainder is direct (but quite long to write down on paper).
  Moreover, we will show this for atoms; the result for near-litters is identical.
  The specifications \( \spec(S) \) and \( \spec(T) \) give rise to the same trees \( R^\Atom \) precisely when
  \[ \forall i,\, \forall j,\, (\exists a,\, (i, a) \in S_{{A_\delta}_B}^\Atom \wedge (j, a) \in \supp(t)_B^\Atom) \leftrightarrow (\exists a,\, (i, a) \in T_{{A_\delta}_B}^\Atom \wedge (j, a) \in \supp(\rho(t))_B^\Atom) \]
  We must show that this holds if and only if
  \[ \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom \to \forall i,\, (i, a) \in S_{{A_\delta}_B}^\Atom \leftrightarrow (i, \rho_B(a)) \in T_{{A_\delta}_B}^\Atom \]
  This can be concluded by appealing to the basic behaviour of \( \rho \) and noting the coinjectivity of \( \supp(t)_B^\Atom \).
\end{proof}
\begin{proposition}
  \uses{def:StrSupport.spec}
  \label{prop:spec_smul}
  Let \( \rho \) be \( \beta \)-allowable, and let \( S \) be a \( \beta \)-support.
  Then \( \spec(\rho(S)) = \spec(S) \).
\end{proposition}
\begin{proof}
  \uses{prop:spec_eq_spec_iff}
  We appeal to \cref{prop:spec_eq_spec_iff}.
  Clearly the coimage condition holds.

  For the atom condition, we must check that if \( (i, a) \in S_A^\Atom \), we have
  \[ \forall j,\, (j, a) \in S_A^\Atom \leftrightarrow (j, \rho_A(a)) \in \rho(S)_A^\Atom \]
  and
  \[ \forall j,\, (\exists N,\, (j, N) \in S_A^\NearLitter \wedge a \in N) \leftrightarrow (\exists N,\, (j, N) \in \rho(S)_A^\NearLitter \wedge \rho_A(a) \in N) \]
  both of which are trivial.

  For the flexible condition, we must check that if \( (i, N) \in S_A^\NearLitter \) and \( N^\circ \) is \( A \)-flexible, then \( \rho_A(N)^\circ \) is also \( A \)-flexible (which is direct, and should already be its own lemma), and that
  \[ \forall j,\, (\exists N',\, (j, N') \in S_A^\NearLitter \wedge N^\circ = {N'}^\circ) \leftrightarrow (\exists N',\, (j, N') \in \rho(S)_A^\NearLitter \wedge \rho(N)^\circ = {N'}^\circ) \]
  which is similarly trivial.

  Finally, for the inflexible condition, suppose that \( I = (\gamma,\delta,\varepsilon) \) is an inflexible \( \beta \)-path and \( t : \Tang_\delta \).
  Let \( (i, N) \in S_{{A_\varepsilon}_\bot}^\NearLitter \) be such that \( N^\circ = f_{\delta,\varepsilon}(t) \).
  Then by the coherence condition,
  \[ \rho_{{A_\varepsilon}_\bot}(N)^\circ = \rho_{{A_\varepsilon}_\bot}(N^\circ) = \rho_{{A_\varepsilon}_\bot}(f_{\delta,\varepsilon}(t)) = f_{\delta,\varepsilon}(\rho_{A_\delta}(t)) \]
  We must check that
  \begin{align*}
    \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom &\to \forall i,\, (i, a) \in S_{{A_\delta}_B}^\Atom \leftrightarrow (i, (\rho_{A_\delta})_B(a)) \in \rho(S)_{{A_\delta}_B}^\Atom \\
    \forall j,\, \forall N,\, (j, N) \in \supp(t)_B^\NearLitter &\to \forall i,\, (i, N) \in S_{{A_\delta}_B}^\NearLitter \leftrightarrow (i, (\rho_{A_\delta})_B(N)) \in \rho(S)_{{A_\delta}_B}^\NearLitter
  \end{align*}
  which again is trivial.
\end{proof}
\begin{definition}
  \uses{def:BaseSupport}
  \label{def:conv_base}
  Let \( S \) and \( T \) be base supports.
  We define the relations \( \conv_{S,T}^\Atom, \conv_{S,T}^\NearLitter \) by the constructors\footnote{This should be abstracted out even further; this can be defined for any pair of relations with common domain.}
  \begin{align*}
    &(i, a_1) \in S^\Atom \to (i, a_2) \in T^\Atom \to (a_1, a_2) \in \conv_{S,T}^\Atom \\
    &(i, N_1) \in S^\NearLitter \to (i, N_2) \in T^\NearLitter \to (N_1, N_2) \in \conv_{S,T}^\NearLitter
  \end{align*}
  Note that \( {\conv_{S,T}^\Atom}^{-1} = \conv_{T,S}^\Atom \) and \( {\conv_{S,T}^\NearLitter}^{-1} = \conv_{T,S}^\NearLitter \).
\end{definition}
\begin{proposition}
  \uses{def:conv_base,def:StrSupport.spec}
  \label{prop:conv_one_to_one}
  Let \( S, T \) be supports such that \( \spec(S) = \spec(T) \).
  Then \( \conv_{S_A, T_A}^\Atom \) is one-to-one.
\end{proposition}
\begin{proof}
  \uses{prop:spec_eq_spec_iff}
  If \( (a_1, a_2), (a_1, a_3) \in \conv_{S_A, T_A}^\Atom \), then there are \( i, j \) such that \( (i, a_1), (j, a_1) \in S_A^\Atom \) and \( (i, a_2), (j, a_3) \in T_A^\Atom \).
  By \cref{prop:spec_eq_spec_iff}, we deduce \( (j, a_1) \in S_A^\Atom \leftrightarrow (j, a_2) \in T_A^\Atom \), so by coinjectivity of \( T_A^\Atom \), we deduce \( a_2 = a_3 \).
  Hence \( \conv_{S_A, T_A}^\Atom \) is coinjective.
  By symmetry, \( \conv_{S_A, T_A}^\Atom \) is one-to-one.
\end{proof}
\begin{proposition}
  \uses{def:conv_base,def:StrSupport.spec}
  \label{prop:conv_mem_nearLitter_iff}
  Let \( S, T \) be supports such that \( \spec(S) = \spec(T) \).
  If \( (a_1, a_2) \in \conv_{S_A, T_A}^\Atom \) and \( (N_1, N_2) \in \conv_{S_A, T_A}^\NearLitter \), then \( a_1 \in N_1 \) if and only if \( a_2 \in N_2 \).
\end{proposition}
\begin{proof}
  \uses{prop:spec_eq_spec_iff}
  As \( (a_1, a_2) \in \conv_{S_A, T_A}^\Atom \), there is \( i \) such that \( (i, a_1) \in S_A^\Atom \) and \( (i, a_2) \in T_A^\Atom \), and as \( (N_1, N_2) \in \conv_{S_A, T_A}^\NearLitter \), there is \( j \) such that \( (j, N_1) \in S_A^\NearLitter \) and \( (j, N_2) \in T_A^\NearLitter \).
  By \cref{prop:spec_eq_spec_iff}, we deduce that
  \[ \forall j,\, (\exists N,\, (j, N) \in S_A^\NearLitter \wedge a_1 \in N) \leftrightarrow (\exists N,\, (j, N) \in T_A^\NearLitter \wedge a_2 \in N) \]
  If \( a_1 \in N_1 \), then as \( (j, N_1) \in S_A^\NearLitter \), we deduce that there is a near-litter \( N' \) such that \( (j, N') \in T_A^\NearLitter \) and \( a \in N' \).
  But \( T_A^\NearLitter \) is coinjective, so \( N' = N_2 \), giving \( a \in N_2 \).
  The converse holds by symmetry.
\end{proof}
\begin{proposition}
  \uses{def:conv_base,def:StrSupport.spec,def:Strong}
  \label{prop:conv_circ_eq_circ_iff}
  Let \( S, T \) be supports such that \( T \) is strong and \( \spec(S) = \spec(T) \).
  If \( (N_1, N_3), (N_2, N_4) \in \conv_{S_A, T_A}^\NearLitter \), then \( N_1^\circ = N_2^\circ \) if and only if \( N_3^\circ = N_4^\circ \).
\end{proposition}
\begin{proof}
  \uses{prop:spec_eq_spec_iff}
  There are \( i, j \) such that \( (i, N_1), (j, N_2) \in S_A^\NearLitter \) and \( (i, N_3), (j, N_4) \in T_A^\NearLitter \).
  Suppose that \( N_1^\circ = N_2^\circ \); we show that \( N_3^\circ = N_4^\circ \).

  First, suppose that \( N_1^\circ \) is \( A \)-flexible.
  Then by \cref{prop:spec_eq_spec_iff}, we have
  \[ \forall j,\, (\exists N',\, (j, N') \in S_A^\NearLitter \wedge N_1^\circ = {N'}^\circ) \leftrightarrow (\exists N',\, (j, N') \in T_A^\NearLitter \wedge N_3^\circ = {N'}^\circ) \]
  So as \( (j, N_2) \in S_A^\NearLitter \) and \( N_1^\circ = N_2^\circ \), there is \( N' \) with \( (j, N') \in T_A^\NearLitter \) and \( N_3^\circ = {N'}^\circ \), but clearly \( N' = N_4 \), giving the result.

  Now suppose that \( N_1^\circ \) is \( A \)-inflexible, so there is an inflexible \( \beta \)-path \( (\gamma,\delta,\varepsilon,B) \) and tangle \( t : \Tang_\delta \) such that
  \[ A = {B_\varepsilon}_\bot;\quad N_1^\circ = f_{\delta,\varepsilon}(t) \]
  Then by \cref{prop:spec_eq_spec_iff}, there is some \( \delta \)-allowable \( \rho \) such that \( N_3^\circ = f_{\delta,\varepsilon}(\rho(t)) \) and
  \begin{align*}
    \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom &\to \forall i,\, (i, a) \in S_{{A_\delta}_B}^\Atom \leftrightarrow (i, \rho_B(a)) \in T_{{A_\delta}_B}^\Atom \\
    \forall j,\, \forall N,\, (j, N) \in \supp(t)_B^\NearLitter &\to \forall i,\, (i, N) \in S_{{A_\delta}_B}^\NearLitter \leftrightarrow (i, \rho_B(N)) \in T_{{A_\delta}_B}^\NearLitter
  \end{align*}
  But as \( N_1^\circ = N_2^\circ \), we draw the same conclusion about \( N_2 \) and \( N_4 \), giving a \( \delta \)-allowable permutation \( \rho' \) such that \( N_4^\circ = f_{\delta,\varepsilon}(\rho'(t)) \); note that the inflexible path and tangle in question will be the same for both pairs.
  We also have
  \begin{align*}
    \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom &\to \forall i,\, (i, a) \in S_{{A_\delta}_B}^\Atom \leftrightarrow (i, \rho'_B(a)) \in T_{{A_\delta}_B}^\Atom \\
    \forall j,\, \forall N,\, (j, N) \in \supp(t)_B^\NearLitter &\to \forall i,\, (i, N) \in S_{{A_\delta}_B}^\NearLitter \leftrightarrow (i, \rho'_B(N)) \in T_{{A_\delta}_B}^\NearLitter
  \end{align*}
  Combining these, we obtain
  \begin{align*}
    \forall j,\, \forall a,\, (j, a) \in \supp(t)_B^\Atom &\to \forall i,\, (i, \rho_B(a)) \in T_{{A_\delta}_B}^\Atom \leftrightarrow (i, \rho'_B(a)) \in T_{{A_\delta}_B}^\Atom \\
    \forall j,\, \forall N,\, (j, N) \in \supp(t)_B^\NearLitter &\to \forall i,\, (i, \rho_B(N)) \in T_{{A_\delta}_B}^\NearLitter \leftrightarrow (i, \rho'_B(N)) \in T_{{A_\delta}_B}^\NearLitter
  \end{align*}
  We claim that \( \rho(\supp(t)) = \rho'(\supp(t)) \).
  As \( T \) is strong, for each atom \( a \) such that \( (j, a) \in \supp(t)_B^\Atom \), there is some \( k \) such that \( (i, \rho_B(a)) \in T_{{A_\delta}_B}^\Atom \).
  Thus \( \rho_B(a) = \rho'_B(a) \).
  The same conclusion may be drawn for near-litters.
  Thus \( \rho(\supp(t)) = \rho'(\supp(t)) \), giving \( \rho(t) = \rho'(t) \), and hence \( N_3^\circ = N_4^\circ \).
\end{proof}
\begin{proposition}
  \uses{def:conv_base,def:StrSupport.spec,def:Strong}
  \label{prop:conv_interf}
  Let \( S, T \) be strong supports such that \( \spec(S) = \spec(T) \).
  Then for each \( (N_1, N_3), (N_2, N_4) \in \conv_{S_A, T_A}^\NearLitter \),
  \[ \interf(N_1, N_2) \subseteq \coim \conv_{S_A, T_A}^\Atom;\quad \interf(N_3, N_4) \subseteq \im \conv_{S_A, T_A}^\Atom \]
\end{proposition}
\begin{proof}
  As \( S \) is strong, we have \( \interf(N_1, N_2) \subseteq \im S_A^\Atom \).
  But \( \coim \conv_{S_A, T_A}^\Atom = \im S_A^\Atom \), as required.\footnote{Make this a lemma.}
  The result for \( \interf(N_3, N_4) \) then follows by symmetry.
\end{proof}
\begin{definition}
  \uses{prop:conv_one_to_one,prop:conv_mem_nearLitter_iff,prop:conv_circ_eq_circ_iff,prop:conv_interf}
  \label{def:conv}
  Let \( S, T \) be strong \( \beta \)-supports such that \( \spec(S) = \spec(T) \).
  Then for each \( A \), we define the base action \( \conv_{S_A, T_A} \) to be \( (\conv_{S_A, T_A}^\Atom, \conv_{S_A, T_A}^\NearLitter) \); this is a base action by \cref{prop:conv_one_to_one,prop:conv_mem_nearLitter_iff,prop:conv_circ_eq_circ_iff,prop:conv_interf}.
  We now define the \( \beta \)-action \( \conv_{S,T} \) by \( (\conv_{S,T})_A = \conv_{S_A,T_A} \).
\end{definition}
\begin{proposition}
  \label{prop:conv_coherent}
  \uses{def:conv}
  Let \( S, T \) be strong supports such that \( \spec(S) = \spec(T) \).
  Then \( \conv_{S,T} \) is coherent.
\end{proposition}
\begin{proof}
  Suppose that \( (N_1, N_2) \in \conv_{S_A,T_A}^\NearLitter \), so there is \( i \) such that \( (i, N_1) \in S_A^\NearLitter \) and \( (i, N_2) \in T_A^\NearLitter \).

  Suppose that \( N_1^\circ \) is \( A \)-flexible.
  By \cref{prop:spec_eq_spec_iff}, we immediately conclude that \( N_2^\circ \) is \( A \)-flexible as required.

  Now suppose that \( N_1^\circ \) is \( A \)-inflexible with inflexible \( \beta \)-path \( I = (\gamma,\delta,\varepsilon,B) \) and tangle \( t : \Tang_\delta \).
  By \cref{prop:spec_eq_spec_iff}, there is some \( \delta \)-allowable permutation \( \rho \) such that \( N_2^\circ = f_{\delta,\varepsilon}(\rho(t)) \) and
  \begin{align*}
    \forall j,\, \forall a,\, (j, a) \in \supp(t)_C^\Atom &\to \forall i,\, (i, a) \in S_{{B_\delta}_C}^\Atom \leftrightarrow (i, \rho_C(a)) \in T_{{B_\delta}_C}^\Atom \\
    \forall j,\, \forall N,\, (j, N) \in \supp(t)_C^\NearLitter &\to \forall i,\, (i, N) \in S_{{B_\delta}_C}^\NearLitter \leftrightarrow (i, \rho_C(N)) \in T_{{B_\delta}_C}^\NearLitter
  \end{align*}
  We must show that \( ((\conv_{S,T})_B)_\delta(\supp(t)) = \rho(\supp(t)) \).
  We will show the result for atoms; the result for near-litters is identical.
  Let \( (j, a) \in \supp(t)_C^\Atom \).
  Then as \( S \) is strong, there is \( k \) such that \( (k, a) \in S_{{B_\delta}_C}^\Atom \).
  Then by the equation above, \( (k, \rho_C(a)) \in T_{{B_\delta}_C}^\Atom \).
  Hence \( (a, \rho_C(a)) \in (((\conv_{S,T})_B)_\delta)_C \) as required.
\end{proof}
\begin{proposition}
  \uses{def:StrSupport.spec,def:Strong}
  \label{prop:exists_allowable_of_spec_eq_spec}
  Let \( S, T \) be strong supports such that \( \spec(S) = \spec(T) \).
  Then there is an allowable permutation \( \rho \) such that \( \rho(S) = T \).
\end{proposition}
\begin{proof}
  \uses{prop:conv_coherent,thm:StrAction.foa}
  By \cref{prop:conv_coherent}, we may apply \cref{thm:StrAction.foa} to \( \conv_{S,T} \) to obtain an allowable permutation \( \rho \) that \( \conv_{S,T} \) approximates, which directly gives \( \rho(S) = T \) as required.
\end{proof}

\section{Recoding}
\begin{definition}
  \uses{def:CodingFunction,def:CoherentData}
  \label{def:Combination}
  Let \( \gamma < \beta \) be proper type indices at most \( \alpha \).
  An object \( x : \TSet_\beta \) is called a \emph{\( \gamma \)-combination} of a set of \( \beta \)-coding functions \( s \) with respect to a \( \beta \)-support \( S \) if
  \[ U_\beta(x)(\gamma) = \bigcup_{(V, v) \in \chi \in s,\, V \geq S} U_\beta(v)(\gamma) \]
  By extensionality, a set of coding functions \( s \) has at most one \( \gamma \)-combination with respect to a given support \( S \).
\end{definition}
\begin{proposition}
  \uses{def:Combination}
  \label{prop:Combination.smul}
  If \( x \) is a \( \gamma \)-combination of \( s \) with respect to \( S \) then \( \rho(x) \) is a \( \gamma \)-combination of \( s \) with respect to \( \rho(S) \).
\end{proposition}
\begin{proof}
  We can calculate
  \begin{align*}
    U_\beta(\rho(x))(\gamma)
    &= \rho_\gamma[U_\beta(x)(\gamma)] \\
    &= \rho_\gamma\left[ \bigcup_{(V, v) \in \chi \in s,\, V \geq S} U_\beta(v)(\gamma) \right] \\
    &= \bigcup_{(V, v) \in \chi \in s,\, V \geq S} \rho_\gamma\left[ U_\beta(v)(\gamma) \right] \\
    &= \bigcup_{(V, v) \in \chi \in s,\, V \geq S} U_\beta(\rho(v))(\gamma) \\
    &= \bigcup_{(V, v) \in \chi \in s,\, V \geq \rho(S)} U_\beta(v)(\gamma)
  \end{align*}
  where the last inequality uses the fact that coding functions are defined on a support orbit.
\end{proof}
\begin{definition}
  \uses{def:Combination,def:SupportOrbit}
  \label{def:raisedCodingFunction}
  Let \( s \) be a set of \( \beta \)-coding functions, and let \( o \) be a \( \beta \)-support orbit such that for each \( S \in o \), \( s \) has a \( \gamma \)-combination \( x \) with respect to \( S \) where \( S \) supports \( x \).
  Then the \emph{\( (\gamma,\beta) \)-raised coding function} for \( (s, o) \) is the relation \( \chi : \StrSupp_\beta \to \TSet_\beta \to \Prop \) defined by the constructor
  \[ \forall S \in o,\, \forall x \text{ combinations of } (s, S),\, (S, x) \in \chi \]
\end{definition}
\begin{proposition}
  \uses{def:raisedCodingFunction}
  \label{prop:raisedCodingFunction_spec}
  The \( (\gamma,\beta) \)-raised coding function for \( (s, o) \) is a coding function.
\end{proposition}
\begin{proof}
  \uses{prop:Combination.smul}
  Coinjectivity follows from uniqueness of combinations.
  The nonemptiness and support orbit conditions follow from the definition, as does the condition that \( (S, x) \in \chi \) implies that \( S \) is a support for \( x \).
  It remains to show that if \( (S, x) \in \chi \) and \( \rho \) is \( \beta \)-allowable, then \( (\rho(S), \rho(x)) \in \chi \), and this follows directly from \cref{prop:Combination.smul}.
\end{proof}
\begin{definition}[designated support]
  \uses{def:ModelData}
  \label{def:designatedSupport}
  For a type index \( \beta \leq \alpha \), a \emph{\( \beta \)-set orbit} is the quotient of \( \TSet_\beta \) under the relation of being in the same orbit under \( \beta \)-allowable permutations.
  We write \( [x] \) for the set orbit of \( x \).
  For each set orbit \( o \), we choose a representative \( \repr(o) : \TSet_\beta \) with \( [\repr(o)] = o \), and define a support \( S_o \) for \( \repr(o) \).
  For each set, we choose a \( \beta \)-allowable permutation \( \twist_t \) with the property that \( \twist_t(\repr([t])) = t \), and we define the \emph{designated support} of \( t \) to be \( \dsupp(t) = \twist_t(S_{[t]}) \).
  This is a support for \( t \).
\end{definition}
\begin{definition}
  \uses{def:designatedSupport}
  \label{def:raisedSingleton}
  Let \( \gamma < \beta \) be proper type indices.
  Let \( S \) be a \( \beta \)-support and let \( u : \TSet_\gamma \).
  Then the \emph{\( (\gamma,\beta ) \)-raised singleton} coding function is
  \[ \rsing(S, u) = \chi_{(\singleton_\beta(u), S + \dsupp(u)^\beta)} \]
  A coding function is called a \emph{\( (\gamma,\beta) \)-raised singleton} if it is of the form \( \rsing(S, u) \).
\end{definition}
\begin{proposition}
  \uses{def:raisedSingleton}
  \label{prop:raise_combination}
  Let \( \gamma < \beta \) be proper type indices, and let \( x : \TSet_\beta \).
  Then for any support \( S \) of \( x \), \( x \) is a combination of the set
  \[ \{ \rsing(S, u) \mid u \in U_\beta(x)(\gamma) \} \]
\end{proposition}
\begin{proof}
  We must show that
  \[ U_\beta(x)(\gamma) = \bigcup_{u \in U_\beta(x)(\gamma),\,(V,v) \in \rsing(S, u),\, V \geq S} U_\beta(v)(\gamma) \]
  First, suppose \( u \in U_\beta(x)(\gamma) \).
  Then we have
  \[ (S + \dsupp(u)^\beta, \singleton_\beta(u)) \in \rsing(S, u);\quad u \in U_\beta(\singleton_\beta(u))(\gamma) \]
  so the left-hand side is contained in the right-hand side.

  For the converse, suppose that \( u \in U_\beta(x)(\gamma) \) and \( (V, v) \in \rsing(S, u) \) with \( V \geq S \).
  As \( (V, v) \in \rsing(S, u) \), there is some \( \beta \)-allowable \( \rho \) such that
  \[ \rho(S + \dsupp(u)^\beta) = V;\quad \rho(\singleton_\beta(u)) = v \]
  As \( V \geq S \), we obtain \( \rho(S) = S \),\footnote{This is a good lemma.} so \( \rho(x) = x \).
  Then
  \begin{align*}
    U_\beta(v)(\gamma)
    &= U_\beta(\rho(\singleton_\beta(u)))(\gamma) \\
    &= U_\beta(\singleton_\beta(\rho_\gamma(u)))(\gamma) \\
    &= \{ \rho_\gamma(u) \} \\
    &\subseteq U_\beta(\rho(x))(\gamma) \\
    &= U_\beta(x)(\gamma)
  \end{align*}
  as required.
\end{proof}
\begin{proposition}
  \uses{def:raisedSingleton,prop:raisedCodingFunction_spec}
  \label{prop:recode}
  Let \( \gamma < \beta \) be proper type indices, and let \( \chi \) be a \( \beta \)-coding function.
  Then there is a set of \( (\gamma,\beta) \)-raised singletons \( s \) and support orbit \( o \) such that \( \chi \) is the \( (\gamma,\beta) \)-raised coding function for \( (s, o) \).
\end{proposition}
\begin{proof}
  \uses{prop:raise_combination}
  Let \( \chi \) be a \( \beta \)-coding function, and let \( (S, x) \in \chi \).
  Let
  \[ s = \{ \rsing(S, u) \mid u \in U_\beta(x)(\gamma) \} \]
  Let \( o \) be the support orbit such that \( T \in o \) if and only if \( T \in \coim \chi \).
  We claim that \( \chi \) is the raised coding function for \( (s, o) \).
  It suffices to show that \( (S, x) \) is in this raised coding function.
  That is, we must show that \( S \in o \), which is trivial, and that \( x \) is a combination of \( s \), which is the content of \cref{prop:raise_combination}.
\end{proof}

\section{Coding the base type}
\begin{proposition}[the swap permutation]
  \uses{def:BaseSupport,def:Interference}
  \label{prop:exists_swap}
  Let \( S \) be a base support that is closed under interference of near-litters.
  Let \( a_1, a_2 \) be atoms not in \( \im S^\Atom \) such that
  \[ \forall N \in \im S^\NearLitter,\, a_1 \in N \leftrightarrow a_2 \in N \]
  Then there is a base permutation \( \pi \) that fixes \( S \) and maps \( a_1 \) to \( a_2 \).
\end{proposition}
\begin{proof}
  \uses{prop:spec_eq_spec_iff,prop:exists_allowable_of_spec_eq_spec}
  Let \( i \) be an index that does not occur in \( \coim S^\Atom \), and define \( T_1, T_2 \) by
  \[ U_n^\Atom = S^\Atom \sqcup \{ (i, a_n) \};\quad U_n^\NearLitter = S^\NearLitter \]
  for \( n = 1, 2 \).
  We claim that \( T_1 \) and \( T_2 \) are have the same specification, treated as \( \bot \)-supports.
  By appealing to \cref{prop:spec_eq_spec_iff} and noting that every litter is flexible for the unique path \( \bot \tpath \bot \), it suffices to check:
  \begin{itemize}
    \item (atom condition) For all \( i, a_1, a_2 \), if \( (i, a_1) \in T_1^\Atom \) and \( (i, a_2) \in T_2^\Atom \), we have
    \[ \forall j,\, (j, a_1) \in T_1^\Atom \leftrightarrow (j, a_2) \in T_2^\Atom \]
    and
    \[ \forall j,\, (\exists N,\, (j, N) \in T_1^\NearLitter \wedge a_1 \in N) \leftrightarrow (\exists N,\, (j, N) \in T_2^\NearLitter \wedge a_2 \in N) \]
    \item (litter condition) For all \( i, N_1, N_2 \), if \( (i, N_1) \in T_1^\NearLitter \) and \( (i, N_2) \in T_2^\NearLitter \), we have
    \[ \forall j,\, (\exists N',\, (j, N') \in T_1^\NearLitter \wedge N_1^\circ = {N'}^\circ) \leftrightarrow (\exists N',\, (j, N') \in T_2^\NearLitter \wedge N_2^\circ = {N'}^\circ) \]
  \end{itemize}
  The atom condition follows directly from the two assumptions, and the litter condition is vacuously true as \( T_1^\NearLitter = T_2^\NearLitter \).

  Note also that \( T_1, T_2 \) are strong, treated as \( \bot \)-supports.
  Then, by \cref{prop:exists_allowable_of_spec_eq_spec}, there is a \( \bot \)-allowable permutation \( \pi \) such that \( \pi(T_1) = T_2 \).
  Thus, \( \pi(S) = S \) and \( \pi(a_1) = a_2 \).
\end{proof}
\begin{proposition}
  \uses{def:BaseSupport,def:Interference}
  \label{prop:supports_atoms_iff}
  Let \( S \) be a base support that is closed under interference of near-litters.
  Suppose that \( S \) supports a set \( s : \Set \Atom \) under the action of base permutations.
  Then for every pair of atoms \( a_1, a_2 \), the statements
  \[ a_1, a_2 \notin \im S^\Atom \]
  and
  \[ \forall N \in \im S^\NearLitter,\, a_1 \in N \leftrightarrow a_2 \in N \]
  imply that \( a_1 \in s \leftrightarrow a_2 \in s \).
\end{proposition}
\begin{proof}
  \uses{prop:exists_swap}
  Let \( a_1, a_2 \) be atoms that satisfy the two statements.
  By \cref{prop:exists_swap}, there is a base permutation \( \pi \) that fixes \( S \) and maps \( a_1 \) to \( a_2 \).
  As \( S \) supports \( s \), we obtain \( \pi(s) = s \).
  So \( a_1 \in s \) if and only if \( a_2 \in s \), as required.
\end{proof}
\begin{proposition}
  \uses{def:BaseSupport,def:BasePerm}
  \label{prop:card_supports_atoms}
  Let \( S \) be a base support.
  Then \( S \) supports at most \( 2^{\#\kappa} \)-many sets \( s : \Set \Atom \) under the action of base permutations.
\end{proposition}
\begin{proof}
  \uses{prop:supports_atoms_iff}
  Without loss of generality, we may assume \( S \) is closed under interference of near-litters, since extensions will support any object that the original support supports.\footnote{This closure operation should have been developed for \cref{prop:exists_strong}.}
  The \emph{information} of a set \( s : \Set \Atom \) for a base support \( S \) is a triple \( (i^\Atom, i^\NearLitter, p) \) where
  \begin{itemize}
    \item \( i^\Atom \) is the set of indices \( i \) such that \( (i, a) \in S^\Atom \) for some \( a \in s \);
    \item \( i^\NearLitter \) is the set of indices \( i \) such that \( (i, N) \in S^\NearLitter \) for some near-litter \( N \) with \( N \cap s \setminus \im S^\Atom \neq \varnothing \);
    \item \( p \) is the proposition that every atom \( a \notin \im S^\Atom \cup \bigcup \im S^\NearLitter \) lies in \( s \).
  \end{itemize}
  Suppose that \( s, t \) are sets of atoms that \( S \) supports.
  We claim that if \( s \) and \( t \) have the same information \( (i^\Atom, i^\NearLitter, p) \), they are equal.
  By antisymmetry it suffices to show that \( s \subseteq t \).

  Let \( a \in s \).
  Suppose that \( (i, a) \in S^\Atom \) for some \( i \).
  Then \( s \in t \) as \( s, t \) have the same \( i^\Atom \).

  Now suppose that \( a \notin \im S^\Atom \), but that there is some near-litter \( N \) with \( a \in N \) and \( (i, N) \in S^\NearLitter \).
  Then there is some atom \( a' \in N \cap t \setminus \im S^\Atom \).
  It suffices by \cref{prop:supports_atoms_iff} to show that
  \[ \forall N' \in \im S^\NearLitter,\, a \in N' \leftrightarrow a' \in N' \]
  because then \( a \in t \) if and only if \( a' \in t \).
  Suppose that \( a \in N' \) for some \( N' \in \im S^\NearLitter \).
  If \( N^\circ \neq {N'}^\circ \), then \( a \in N \cap N' \setminus \im S^\Atom \) would contradict the assumption that \( S \) is closed under interference.
  So \( N^\circ = {N'}^\circ \).
  If \( a' \notin N' \), then \( a \in (N \symmdiff N') \setminus \im S^\Atom \) would also contradict the assumption that \( S \) is closed under interference.
  Hence \( a' \in N' \) as required.

  Finally, suppose that \( a \notin \im S^\Atom \) and for all near-litters \( N \in \im S^\NearLitter \), we have \( a \notin N \).
  If \( a \notin t \), then \( p \) is false, so there is an atom \( a' \) with the same properties that does not lie in \( s \).
  Again, it suffices by \cref{prop:supports_atoms_iff} to show that
  \[ \forall N' \in \im S^\NearLitter,\, a \in N' \leftrightarrow a' \in N' \]
  because then \( a \in s \) if and only if \( a' \in s \).
  But the left-hand side and the right-hand side are both false, giving the result.

  This result shows that the map that sends a set \( s \) that \( S \) supports to its information is injective, and so as there are \( 2^{\#\kappa} \)-many possible information tuples, there are at most \( 2^{\#\kappa} \)-many sets that \( S \) supports under the action of base permutations.
\end{proof}

\section{Counting}
\begin{proposition}
  \uses{def:Spec}
  \label{prop:card_spec}
  Suppose that for all type indices \( \delta < \beta \), there are strictly less than \( \#\mu \)-many \( \delta \)-coding functions.
  Then there are less than \( \#\mu \) \( \beta \)-specifications.
\end{proposition}
\begin{proof}
  There are less than \( \#\mu \) atom conditions as \( \#\kappa < \#\mu \) and \( \#\mu \) is a strong limit.
  There are less than \( \#\mu \) inflexible \( \beta \)-paths, as each is determined by three type indices less than \( \beta \) and a path with maximum less than \( \beta \), of which there are \( \#\mu \)-many.
  There are less than \( \#\mu \)-many coding functions of any type \( \delta < \beta \), because K\"onig's theorem gives
  \[ \sum_{\delta < \beta} \#\{\delta\text{-coding functions}\} < \prod_{\delta < \beta} \#\mu = \#\mu^{\#\{\delta < \beta\}} = \#\mu \]
  where the last equality follows from the facts that \( \#\{\delta < \beta\} \) has cardinality less than \( \cof(\ord(\#\mu)) \) and that \( \#\mu \) is a strong limit.
  There are less than \( \#\mu \) \( \delta \)-trees of relations on \( \kappa \) for each \( \delta \leq \alpha \), because there are less than \( \#\mu \)-many relations on \( \kappa \) as \( \#\mu \) is a strong limit, allowing us to conclude by one of the remarks in \cref{def:Tree}.
  Hence there are less than \( \#\mu \) \( \beta \)-near-litter conditions.
  We can again apply the result about cardinalities of types of trees to deduce that there are less than \( \#\mu \) \( \beta \)-trees of enumerations of atom conditions and of \( \beta \)-near-litter conditions, as required.
\end{proof}
\begin{definition}
  \uses{def:Spec}
  \label{def:WeakSpec}
  A \emph{weak \( \beta \)-specification} is a triple \( W = (R^\Atom, R^\NearLitter, \sigma) \) where \( R^\Atom, R^\NearLitter \) are \( \beta \)-trees of relations on \( \kappa \), and \( \sigma \) is a \( \beta \)-specification.
  We say that a weak specification \emph{specifies} a support \( S \) if there is a strong support \( T \) such that \( \sigma = \spec(T) \), \( S \preceq T \), and
  \begin{align*}
    (i, j) \in R_A^\Atom &\leftrightarrow \exists a,\, (i, a) \in S_A^\Atom \wedge (j, a) \in T_A^\Atom \\
    (i, j) \in R_A^\NearLitter &\leftrightarrow \exists N,\, (i, N) \in S_A^\NearLitter \wedge (j, N) \in T_A^\NearLitter
  \end{align*}
\end{definition}
\begin{proposition}
  \uses{def:WeakSpec}
  \label{prop:exists_weakSpec}
  Every support has a weak specification that specifies it.
\end{proposition}
\begin{proof}
  \uses{prop:exists_strong}
  Let \( S \) be a support, and let \( T \) be a strong support such that \( S \preceq T \), which exists by \cref{prop:exists_strong}.
  Then simply define \( R^\Atom \) and \( R^\NearLitter \) to be the required relations.
\end{proof}
\begin{proposition}
  \uses{def:WeakSpec}
  \label{prop:exists_allowable_of_weakSpec}
  If \( W \) is a weak specification that specifies supports \( S \) and \( T \), then there is an allowable permutation \( \rho \) such that \( \rho(S) = T \).
\end{proposition}
\begin{proof}
  \uses{prop:exists_allowable_of_spec_eq_spec}
  Let \( W = (R^\Atom, R^\NearLitter, \sigma) \), and let \( U, V \) be strong supports such that \( \spec(U) = \sigma = \spec(V) \), \( S \preceq U, T \preceq V \), and
  \begin{align*}
    (\exists a,\, (i, a) \in S_A^\Atom \wedge (j, a) \in U_A^\Atom) &\leftrightarrow (\exists a,\, (i, a) \in T_A^\Atom \wedge (j, a) \in V_A^\Atom) \\
    (\exists N,\, (i, N) \in S_A^\NearLitter \wedge (j, N) \in U_A^\NearLitter) &\leftrightarrow (\exists N,\, (i, N) \in T_A^\NearLitter \wedge (j, N) \in V_A^\NearLitter)
  \end{align*}
  By \cref{prop:exists_allowable_of_spec_eq_spec}, there is an allowable permutation \( \rho \) such that \( \rho(U) = V \).
  We claim that \( \rho(S) = T \).
  Suppose \( (i, a) \in S_A^\Atom \).
  Then as \( S \preceq U \), there is \( j \) such that \( (j, a) \in U_A^\Atom \).
  So there is \( a' \) such that \( (i, a') \in T_A^\Atom \) and \( (j, a') \in V_A^\Atom \).
  Then \( a' = \rho_A(a) \) as \( \rho(U) = V \), as required.
  The same simple calculation gives the required result for near-litters.
\end{proof}
\begin{proposition}
  \uses{def:WeakSpec}
  \label{prop:card_weakSpec}
  Suppose that for all type indices \( \delta < \beta \), there are strictly less than \( \#\mu \)-many \( \delta \)-coding functions.
  Then there are less than \( \#\mu \) weak \( \beta \)-specifications.
\end{proposition}
\begin{proof}
  \uses{prop:card_spec}
  Follows directly from \cref{prop:card_spec} and the remark that there are less than \( \#\mu \) \( \beta \)-trees of relations on \( \kappa \).
\end{proof}
\begin{proposition}
  \uses{def:SupportOrbit,def:CodingFunction}
  \label{prop:card_supportOrbit}
  Suppose that for all type indices \( \delta < \beta \), there are strictly less than \( \#\mu \)-many \( \delta \)-coding functions.
  Then there are less than \( \#\mu \) \( \beta \)-support orbits.
\end{proposition}
\begin{proof}
  \uses{prop:exists_weakSpec,prop:exists_allowable_of_weakSpec,prop:card_weakSpec}
  Define a function from the type of \( \beta \)-support orbits into the type of weak \( \beta \)-specifications by mapping a representative to a weak specification that specifies it; one will always exist by \cref{prop:exists_weakSpec}.
  This is an injection: if \( o_1, o_2 \) are orbits with representatives \( S_1, S_2 \) and \( S_1, S_2 \) have the same assigned weak specification, then by \cref{prop:exists_allowable_of_weakSpec} there is an allowable permutation \( \rho \) such that \( \rho(S_1) = S_2 \), and so \( o_1 = o_2 \).
  So we are done as there are less than \( \#\mu \) weak \( \beta \)-specifications by \cref{prop:card_weakSpec}.
\end{proof}
\begin{proposition}
  \uses{def:SupportOrbit,def:CodingFunction}
  \label{prop:card_codingFunction_of_card_supports}
  Let \( \beta \) be a type index (which in practice will be \( \bot \) or the lowest proper type index).
  Suppose that there are less than \( \#\mu \) \( \beta \)-support orbits.
  Let \( \nu \) be a cardinal less than \( \#\mu \) such that for each \( \beta \)-support \( S \), there are at most \( \nu \)-many objects \( x : \TSet_\beta \) that \( S \) supports.
  Then there are less than \( \#\mu \) \( \beta \)-coding functions.
\end{proposition}
\begin{proof}
  Every \( \beta \)-coding function is of the form \( \chi_{(x, S)} \) where \( S \) is a representative chosen in advance for a support orbit, and \( x \) is an object that \( S \) supports under the action of \( \beta \)-allowable permutations.
  So there are at most
  \[ \sum_{S \text{ representatives}} \nu = \#\{\text{support orbits}\} \cdot \nu \]
  coding functions, which is less than \( \#\mu \).
\end{proof}
\begin{proposition}
  \uses{def:CodingFunction}
  \label{prop:card_codingFunction_bot}
  There are less than \( \#\mu \) \( \bot \)-coding functions.
\end{proposition}
\begin{proof}
  \uses{prop:card_codingFunction_of_card_supports,prop:card_supportOrbit,prop:card_supports_atoms}
  By \cref{prop:card_codingFunction_of_card_supports}, it suffices to show that there are less than \( \#\mu \) \( \bot \)-support orbits and that there is a bound less than \( \#\mu \) on the amount of objects that a given \( \bot \)-support supports.
  The first result follows from \cref{prop:card_supportOrbit}, which has vacuous assumptions in this case.
  The second result follows from applying \cref{prop:card_supports_atoms} to singletons of atoms, after applying the bijections between \( \bot \)-supports and base supports, and between \( \bot \)-allowable permutations and base permutations.
\end{proof}
\begin{proposition}
  \uses{def:CodingFunction}
  \label{prop:card_codingFunction_min}
  There are less than \( \#\mu \) \( \beta \)-coding functions if \( \beta \) is the minimal inhabitant of \( \lambda \).
\end{proposition}
\begin{proof}
  \uses{prop:card_codingFunction_of_card_supports,prop:card_supportOrbit,prop:card_codingFunction_bot,prop:card_supports_atoms,def:CoherentData}
  Again, we apply \cref{prop:card_codingFunction_of_card_supports}.
  The first claim follows from \cref{prop:card_supportOrbit}, where this time we use the fact that there are less than \( \#\mu \) \( \bot \)-coding functions (\cref{prop:card_codingFunction_bot}).
  The second claim follows from \cref{prop:card_supports_atoms} to \( \bot \)-extensions of type \( \beta \) objects, noting that \( \beta \)-supports correspond to base supports and that \( \beta \)-allowable permutations correspond to base permutations.\footnote{One useful claim to prove for this is that there is a unique path \( \beta \tpath \bot \), and so type \( \beta \) objects satisfy \( \bot \)-extensionality by injectivity of \( U_\beta \).}
  The fact that \( \beta \)-allowable permutations correspond to base permutations relies on the fact that we can construct a \( \beta \)-permutation from a base permutation using coherent data (\cref{def:CoherentData}).
\end{proof}
\begin{proposition}
  \uses{def:CodingFunction,def:raisedSingleton}
  \label{prop:card_raisedSingleton}
  Suppose that for all type indices \( \delta < \beta \), there are strictly less than \( \#\mu \)-many \( \delta \)-coding functions.
  Then if \( \gamma < \beta \) is a proper type index, there are strictly less than \( \#\mu \) \( (\gamma,\beta) \)-raised singletons.
\end{proposition}
\begin{proof}
  \uses{prop:card_supportOrbit}
  A \( (\gamma,\beta) \)-raised singleton \( \rsing(S,u) = \chi_{(\singleton_\beta(u), S + \dsupp(u)^\beta)} \) is determined by a triple \( (R, o, \chi) \) where
  \begin{itemize}
    \item \( R \) is the \( \beta \)-tree given by \( R_A = i \) when \( S_A = (i, f) \);
    \item \( o \) is the support orbit of \( S + \dsupp(u)^\beta \); and
    \item \( \chi \) is the coding function \( \chi_{(u, \dsupp(u))} \).
  \end{itemize}
  Indeed, suppose \( \rsing(S, u) \) and \( \rsing(T, v) \) have the same triple \( (R, o, \chi) \).
  We must show that
  \[ \chi_{(\singleton_\beta(u), S + \dsupp(u)^\beta)} = \chi_{(\singleton_\beta(v), S + \dsupp(v)^\beta)} \]
  Then there is a \( \beta \)-allowable \( \rho \) such that \( \rho(S + \dsupp(u)^\beta) = T + \dsupp(v)^\beta \), and as they have the same tree \( R \), we can decompose this into \( \rho(S) = T \) and \( \rho(\dsupp(u)^\beta) = \dsupp(v)^\beta \).
  In particular, \( \rho_\beta(\dsupp(u)) = \dsupp(v) \).
  As \( \chi_{(u, \dsupp(u))} = \chi_{(v, \dsupp(v))} \), there is a \( \gamma \)-allowable permutation \( \rho' \) such that \( \rho'(u) = v \) and \( \rho'(\dsupp(u)) = \dsupp(v) \).
  Hence \( \rho_\beta(u) = v \).
  This gives
  \[ \rho(\singleton_\beta(u)) = \singleton_\beta(\rho_\beta(u)) = \singleton_\beta(v) \]
  as required.

  Now, it remains to show that there are less than \( \#\mu \) such triples \( (R, o, \chi) \).
  But this follows directly from \cref{prop:card_supportOrbit} and the assumption on the cardinalities of the types of coding functions.
\end{proof}
\begin{proposition}
  \uses{def:CodingFunction}
  \label{prop:card_codingFunction}
  There are less than \( \#\mu \)-many \( \beta \)-coding functions for all type indices \( \beta \leq \alpha \).
\end{proposition}
\begin{proof}
  \uses{prop:card_codingFunction_bot,prop:card_codingFunction_min,prop:recode,prop:card_supportOrbit,prop:card_raisedSingleton}
  By induction we may assume that for all type indices \( \delta < \beta \), there are strictly less than \( \#\mu \)-many \( \delta \)-coding functions.
  By \cref{prop:card_codingFunction_bot,prop:card_codingFunction_min}, we may assume that \( \beta \) is a proper type index, and that it is not minimal in \( \lambda \), so there is some proper type index \( \gamma < \beta \).
  By \cref{prop:recode}, every \( \beta \)-coding function is determined by a set of \( (\gamma,\beta) \)-raised singletons \( s \) and support orbit \( o \).
  The conclusion then follows from \cref{prop:card_supportOrbit,prop:card_raisedSingleton} and the fact that \( \#\mu \) is a strong limit.
\end{proof}
\begin{proposition}
  \uses{def:ModelData}
  \label{prop:card_tSet}
  For each type index \( \beta \leq \alpha \), \( \#\TSet_\beta = \#\mu \).
\end{proposition}
\begin{proof}
  \uses{prop:card_codingFunction}
  If \( \beta \) is \( \bot \), we already know \( \#\TSet_\bot = \#\Atom = \#\mu \), so suppose \( \#\beta \) is a proper type index.
  Each object \( x : \TSet_\beta \) is determined by a \( \beta \)-coding function and a \( \beta \)-support.
  Since there are less than \( \#\mu \)-many \( \beta \)-coding functions (\cref{prop:card_codingFunction}) and there are exactly \( \#\mu \) \( \beta \)-supports, we obtain \( \#\TSet_\beta \leq \#\mu \).
  Since the typed near-litter map \( \NearLitter \to \TSet_\beta \) is injective, there are at least \( \#\NearLitter = \#\mu \) inhabitants of \( \TSet_\beta \), giving the result by antisymmetry.
\end{proof}
\begin{proposition}
  \uses{def:Tangle}
  \label{prop:card_tangle}
  For each type index \( \beta \leq \alpha \), \( \#\Tang_\beta = \#\mu \).
\end{proposition}
\begin{proof}
  \uses{prop:card_tSet}
  Use \cref{prop:card_tSet} and the fact that there are precisely \( \#\mu \)-many \( \beta \)-supports.
\end{proof}
